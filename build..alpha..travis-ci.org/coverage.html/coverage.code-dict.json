{"/home/travis/build/npmtest/node-npmtest-css-layout/test.js":"/* istanbul instrument in package npmtest_css_layout */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-css-layout/lib.npmtest_css_layout.js":"/* istanbul instrument in package npmtest_css_layout */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_css_layout = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_css_layout = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-css-layout/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-css-layout && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_css_layout */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_css_layout\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_css_layout.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_css_layout.rollup.js'] =\n            local.assetsDict['/assets.npmtest_css_layout.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_css_layout.__dirname + '/lib.npmtest_css_layout.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-css-layout/node_modules/css-layout/dist/css-layout.js":"// UMD (Universal Module Definition)\n// See https://github.com/umdjs/umd for reference\n//\n// This file uses the following specific UMD implementation:\n// https://github.com/umdjs/umd/blob/master/returnExports.js\n(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.computeLayout = factory();\n  }\n}(this, function() {\n  /**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\nvar computeLayout = (function() {\n\n  var CSS_UNDEFINED;\n\n  var CSS_DIRECTION_INHERIT = 'inherit';\n  var CSS_DIRECTION_LTR = 'ltr';\n  var CSS_DIRECTION_RTL = 'rtl';\n\n  var CSS_FLEX_DIRECTION_ROW = 'row';\n  var CSS_FLEX_DIRECTION_ROW_REVERSE = 'row-reverse';\n  var CSS_FLEX_DIRECTION_COLUMN = 'column';\n  var CSS_FLEX_DIRECTION_COLUMN_REVERSE = 'column-reverse';\n\n  var CSS_JUSTIFY_FLEX_START = 'flex-start';\n  var CSS_JUSTIFY_CENTER = 'center';\n  var CSS_JUSTIFY_FLEX_END = 'flex-end';\n  var CSS_JUSTIFY_SPACE_BETWEEN = 'space-between';\n  var CSS_JUSTIFY_SPACE_AROUND = 'space-around';\n\n  var CSS_ALIGN_FLEX_START = 'flex-start';\n  var CSS_ALIGN_CENTER = 'center';\n  var CSS_ALIGN_FLEX_END = 'flex-end';\n  var CSS_ALIGN_STRETCH = 'stretch';\n\n  var CSS_POSITION_RELATIVE = 'relative';\n  var CSS_POSITION_ABSOLUTE = 'absolute';\n\n  var leading = {\n    'row': 'left',\n    'row-reverse': 'right',\n    'column': 'top',\n    'column-reverse': 'bottom'\n  };\n  var trailing = {\n    'row': 'right',\n    'row-reverse': 'left',\n    'column': 'bottom',\n    'column-reverse': 'top'\n  };\n  var pos = {\n    'row': 'left',\n    'row-reverse': 'right',\n    'column': 'top',\n    'column-reverse': 'bottom'\n  };\n  var dim = {\n    'row': 'width',\n    'row-reverse': 'width',\n    'column': 'height',\n    'column-reverse': 'height'\n  };\n\n  // When transpiled to Java / C the node type has layout, children and style\n  // properties. For the JavaScript version this function adds these properties\n  // if they don't already exist.\n  function fillNodes(node) {\n    if (!node.layout || node.isDirty) {\n      node.layout = {\n        width: undefined,\n        height: undefined,\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0\n      };\n    }\n\n    if (!node.style) {\n      node.style = {};\n    }\n\n    if (!node.children) {\n      node.children = [];\n    }\n    node.children.forEach(fillNodes);\n    return node;\n  }\n\n  function isUndefined(value) {\n    return value === undefined;\n  }\n\n  function isRowDirection(flexDirection) {\n    return flexDirection === CSS_FLEX_DIRECTION_ROW ||\n           flexDirection === CSS_FLEX_DIRECTION_ROW_REVERSE;\n  }\n\n  function isColumnDirection(flexDirection) {\n    return flexDirection === CSS_FLEX_DIRECTION_COLUMN ||\n           flexDirection === CSS_FLEX_DIRECTION_COLUMN_REVERSE;\n  }\n\n  function getLeadingMargin(node, axis) {\n    if (node.style.marginStart !== undefined && isRowDirection(axis)) {\n      return node.style.marginStart;\n    }\n\n    var value = null;\n    switch (axis) {\n      case 'row':            value = node.style.marginLeft;   break;\n      case 'row-reverse':    value = node.style.marginRight;  break;\n      case 'column':         value = node.style.marginTop;    break;\n      case 'column-reverse': value = node.style.marginBottom; break;\n    }\n\n    if (value !== undefined) {\n      return value;\n    }\n\n    if (node.style.margin !== undefined) {\n      return node.style.margin;\n    }\n\n    return 0;\n  }\n\n  function getTrailingMargin(node, axis) {\n    if (node.style.marginEnd !== undefined && isRowDirection(axis)) {\n      return node.style.marginEnd;\n    }\n\n    var value = null;\n    switch (axis) {\n      case 'row':            value = node.style.marginRight;  break;\n      case 'row-reverse':    value = node.style.marginLeft;   break;\n      case 'column':         value = node.style.marginBottom; break;\n      case 'column-reverse': value = node.style.marginTop;    break;\n    }\n\n    if (value != null) {\n      return value;\n    }\n\n    if (node.style.margin !== undefined) {\n      return node.style.margin;\n    }\n\n    return 0;\n  }\n\n  function getLeadingPadding(node, axis) {\n    if (node.style.paddingStart !== undefined && node.style.paddingStart >= 0\n        && isRowDirection(axis)) {\n      return node.style.paddingStart;\n    }\n\n    var value = null;\n    switch (axis) {\n      case 'row':            value = node.style.paddingLeft;   break;\n      case 'row-reverse':    value = node.style.paddingRight;  break;\n      case 'column':         value = node.style.paddingTop;    break;\n      case 'column-reverse': value = node.style.paddingBottom; break;\n    }\n\n    if (value != null && value >= 0) {\n      return value;\n    }\n\n    if (node.style.padding !== undefined && node.style.padding >= 0) {\n      return node.style.padding;\n    }\n\n    return 0;\n  }\n\n  function getTrailingPadding(node, axis) {\n    if (node.style.paddingEnd !== undefined && node.style.paddingEnd >= 0\n        && isRowDirection(axis)) {\n      return node.style.paddingEnd;\n    }\n\n    var value = null;\n    switch (axis) {\n      case 'row':            value = node.style.paddingRight;  break;\n      case 'row-reverse':    value = node.style.paddingLeft;   break;\n      case 'column':         value = node.style.paddingBottom; break;\n      case 'column-reverse': value = node.style.paddingTop;    break;\n    }\n\n    if (value != null && value >= 0) {\n      return value;\n    }\n\n    if (node.style.padding !== undefined && node.style.padding >= 0) {\n      return node.style.padding;\n    }\n\n    return 0;\n  }\n\n  function getLeadingBorder(node, axis) {\n    if (node.style.borderStartWidth !== undefined && node.style.borderStartWidth >= 0\n        && isRowDirection(axis)) {\n      return node.style.borderStartWidth;\n    }\n\n    var value = null;\n    switch (axis) {\n      case 'row':            value = node.style.borderLeftWidth;   break;\n      case 'row-reverse':    value = node.style.borderRightWidth;  break;\n      case 'column':         value = node.style.borderTopWidth;    break;\n      case 'column-reverse': value = node.style.borderBottomWidth; break;\n    }\n\n    if (value != null && value >= 0) {\n      return value;\n    }\n\n    if (node.style.borderWidth !== undefined && node.style.borderWidth >= 0) {\n      return node.style.borderWidth;\n    }\n\n    return 0;\n  }\n\n  function getTrailingBorder(node, axis) {\n    if (node.style.borderEndWidth !== undefined && node.style.borderEndWidth >= 0\n        && isRowDirection(axis)) {\n      return node.style.borderEndWidth;\n    }\n\n    var value = null;\n    switch (axis) {\n      case 'row':            value = node.style.borderRightWidth;  break;\n      case 'row-reverse':    value = node.style.borderLeftWidth;   break;\n      case 'column':         value = node.style.borderBottomWidth; break;\n      case 'column-reverse': value = node.style.borderTopWidth;    break;\n    }\n\n    if (value != null && value >= 0) {\n      return value;\n    }\n\n    if (node.style.borderWidth !== undefined && node.style.borderWidth >= 0) {\n      return node.style.borderWidth;\n    }\n\n    return 0;\n  }\n\n  function getLeadingPaddingAndBorder(node, axis) {\n    return getLeadingPadding(node, axis) + getLeadingBorder(node, axis);\n  }\n\n  function getTrailingPaddingAndBorder(node, axis) {\n    return getTrailingPadding(node, axis) + getTrailingBorder(node, axis);\n  }\n\n  function getBorderAxis(node, axis) {\n    return getLeadingBorder(node, axis) + getTrailingBorder(node, axis);\n  }\n\n  function getMarginAxis(node, axis) {\n    return getLeadingMargin(node, axis) + getTrailingMargin(node, axis);\n  }\n\n  function getPaddingAndBorderAxis(node, axis) {\n    return getLeadingPaddingAndBorder(node, axis) +\n        getTrailingPaddingAndBorder(node, axis);\n  }\n\n  function getJustifyContent(node) {\n    if (node.style.justifyContent) {\n      return node.style.justifyContent;\n    }\n    return 'flex-start';\n  }\n\n  function getAlignContent(node) {\n    if (node.style.alignContent) {\n      return node.style.alignContent;\n    }\n    return 'flex-start';\n  }\n\n  function getAlignItem(node, child) {\n    if (child.style.alignSelf) {\n      return child.style.alignSelf;\n    }\n    if (node.style.alignItems) {\n      return node.style.alignItems;\n    }\n    return 'stretch';\n  }\n\n  function resolveAxis(axis, direction) {\n    if (direction === CSS_DIRECTION_RTL) {\n      if (axis === CSS_FLEX_DIRECTION_ROW) {\n        return CSS_FLEX_DIRECTION_ROW_REVERSE;\n      } else if (axis === CSS_FLEX_DIRECTION_ROW_REVERSE) {\n        return CSS_FLEX_DIRECTION_ROW;\n      }\n    }\n\n    return axis;\n  }\n\n  function resolveDirection(node, parentDirection) {\n    var direction;\n    if (node.style.direction) {\n      direction = node.style.direction;\n    } else {\n      direction = CSS_DIRECTION_INHERIT;\n    }\n\n    if (direction === CSS_DIRECTION_INHERIT) {\n      direction = (parentDirection === undefined ? CSS_DIRECTION_LTR : parentDirection);\n    }\n\n    return direction;\n  }\n\n  function getFlexDirection(node) {\n    if (node.style.flexDirection) {\n      return node.style.flexDirection;\n    }\n    return CSS_FLEX_DIRECTION_COLUMN;\n  }\n\n  function getCrossFlexDirection(flexDirection, direction) {\n    if (isColumnDirection(flexDirection)) {\n      return resolveAxis(CSS_FLEX_DIRECTION_ROW, direction);\n    } else {\n      return CSS_FLEX_DIRECTION_COLUMN;\n    }\n  }\n\n  function getPositionType(node) {\n    if (node.style.position) {\n      return node.style.position;\n    }\n    return 'relative';\n  }\n\n  function isFlex(node) {\n    return (\n      getPositionType(node) === CSS_POSITION_RELATIVE &&\n      node.style.flex > 0\n    );\n  }\n\n  function isFlexWrap(node) {\n    return node.style.flexWrap === 'wrap';\n  }\n\n  function getDimWithMargin(node, axis) {\n    return node.layout[dim[axis]] + getMarginAxis(node, axis);\n  }\n\n  function isDimDefined(node, axis) {\n    return node.style[dim[axis]] !== undefined && node.style[dim[axis]] >= 0;\n  }\n\n  function isPosDefined(node, pos) {\n    return node.style[pos] !== undefined;\n  }\n\n  function isMeasureDefined(node) {\n    return node.style.measure !== undefined;\n  }\n\n  function getPosition(node, pos) {\n    if (node.style[pos] !== undefined) {\n      return node.style[pos];\n    }\n    return 0;\n  }\n\n  function boundAxis(node, axis, value) {\n    var min = {\n      'row': node.style.minWidth,\n      'row-reverse': node.style.minWidth,\n      'column': node.style.minHeight,\n      'column-reverse': node.style.minHeight\n    }[axis];\n\n    var max = {\n      'row': node.style.maxWidth,\n      'row-reverse': node.style.maxWidth,\n      'column': node.style.maxHeight,\n      'column-reverse': node.style.maxHeight\n    }[axis];\n\n    var boundValue = value;\n    if (max !== undefined && max >= 0 && boundValue > max) {\n      boundValue = max;\n    }\n    if (min !== undefined && min >= 0 && boundValue < min) {\n      boundValue = min;\n    }\n    return boundValue;\n  }\n\n  function fmaxf(a, b) {\n    if (a > b) {\n      return a;\n    }\n    return b;\n  }\n\n  // When the user specifically sets a value for width or height\n  function setDimensionFromStyle(node, axis) {\n    // The parent already computed us a width or height. We just skip it\n    if (node.layout[dim[axis]] !== undefined) {\n      return;\n    }\n    // We only run if there's a width or height defined\n    if (!isDimDefined(node, axis)) {\n      return;\n    }\n\n    // The dimensions can never be smaller than the padding and border\n    node.layout[dim[axis]] = fmaxf(\n      boundAxis(node, axis, node.style[dim[axis]]),\n      getPaddingAndBorderAxis(node, axis)\n    );\n  }\n\n  function setTrailingPosition(node, child, axis) {\n    child.layout[trailing[axis]] = node.layout[dim[axis]] -\n        child.layout[dim[axis]] - child.layout[pos[axis]];\n  }\n\n  // If both left and right are defined, then use left. Otherwise return\n  // +left or -right depending on which is defined.\n  function getRelativePosition(node, axis) {\n    if (node.style[leading[axis]] !== undefined) {\n      return getPosition(node, leading[axis]);\n    }\n    return -getPosition(node, trailing[axis]);\n  }\n\n  function layoutNodeImpl(node, parentMaxWidth, /*css_direction_t*/parentDirection) {\n    var/*css_direction_t*/ direction = resolveDirection(node, parentDirection);\n    var/*(c)!css_flex_direction_t*//*(java)!int*/ mainAxis = resolveAxis(getFlexDirection(node), direction);\n    var/*(c)!css_flex_direction_t*//*(java)!int*/ crossAxis = getCrossFlexDirection(mainAxis, direction);\n    var/*(c)!css_flex_direction_t*//*(java)!int*/ resolvedRowAxis = resolveAxis(CSS_FLEX_DIRECTION_ROW, direction);\n\n    // Handle width and height style attributes\n    setDimensionFromStyle(node, mainAxis);\n    setDimensionFromStyle(node, crossAxis);\n\n    // Set the resolved resolution in the node's layout\n    node.layout.direction = direction;\n\n    // The position is set by the parent, but we need to complete it with a\n    // delta composed of the margin and left/top/right/bottom\n    node.layout[leading[mainAxis]] += getLeadingMargin(node, mainAxis) +\n      getRelativePosition(node, mainAxis);\n    node.layout[trailing[mainAxis]] += getTrailingMargin(node, mainAxis) +\n      getRelativePosition(node, mainAxis);\n    node.layout[leading[crossAxis]] += getLeadingMargin(node, crossAxis) +\n      getRelativePosition(node, crossAxis);\n    node.layout[trailing[crossAxis]] += getTrailingMargin(node, crossAxis) +\n      getRelativePosition(node, crossAxis);\n\n    // Inline immutable values from the target node to avoid excessive method\n    // invocations during the layout calculation.\n    var/*int*/ childCount = node.children.length;\n    var/*float*/ paddingAndBorderAxisResolvedRow = getPaddingAndBorderAxis(node, resolvedRowAxis);\n\n    if (isMeasureDefined(node)) {\n      var/*bool*/ isResolvedRowDimDefined = !isUndefined(node.layout[dim[resolvedRowAxis]]);\n\n      var/*float*/ width = CSS_UNDEFINED;\n      if (isDimDefined(node, resolvedRowAxis)) {\n        width = node.style.width;\n      } else if (isResolvedRowDimDefined) {\n        width = node.layout[dim[resolvedRowAxis]];\n      } else {\n        width = parentMaxWidth -\n          getMarginAxis(node, resolvedRowAxis);\n      }\n      width -= paddingAndBorderAxisResolvedRow;\n\n      // We only need to give a dimension for the text if we haven't got any\n      // for it computed yet. It can either be from the style attribute or because\n      // the element is flexible.\n      var/*bool*/ isRowUndefined = !isDimDefined(node, resolvedRowAxis) && !isResolvedRowDimDefined;\n      var/*bool*/ isColumnUndefined = !isDimDefined(node, CSS_FLEX_DIRECTION_COLUMN) &&\n        isUndefined(node.layout[dim[CSS_FLEX_DIRECTION_COLUMN]]);\n\n      // Let's not measure the text if we already know both dimensions\n      if (isRowUndefined || isColumnUndefined) {\n        var/*css_dim_t*/ measureDim = node.style.measure(\n          /*(c)!node->context,*/\n          /*(java)!layoutContext.measureOutput,*/\n          width\n        );\n        if (isRowUndefined) {\n          node.layout.width = measureDim.width +\n            paddingAndBorderAxisResolvedRow;\n        }\n        if (isColumnUndefined) {\n          node.layout.height = measureDim.height +\n            getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_COLUMN);\n        }\n      }\n      if (childCount === 0) {\n        return;\n      }\n    }\n\n    var/*bool*/ isNodeFlexWrap = isFlexWrap(node);\n\n    var/*css_justify_t*/ justifyContent = getJustifyContent(node);\n\n    var/*float*/ leadingPaddingAndBorderMain = getLeadingPaddingAndBorder(node, mainAxis);\n    var/*float*/ leadingPaddingAndBorderCross = getLeadingPaddingAndBorder(node, crossAxis);\n    var/*float*/ paddingAndBorderAxisMain = getPaddingAndBorderAxis(node, mainAxis);\n    var/*float*/ paddingAndBorderAxisCross = getPaddingAndBorderAxis(node, crossAxis);\n\n    var/*bool*/ isMainDimDefined = !isUndefined(node.layout[dim[mainAxis]]);\n    var/*bool*/ isCrossDimDefined = !isUndefined(node.layout[dim[crossAxis]]);\n    var/*bool*/ isMainRowDirection = isRowDirection(mainAxis);\n\n    var/*int*/ i;\n    var/*int*/ ii;\n    var/*css_node_t**/ child;\n    var/*(c)!css_flex_direction_t*//*(java)!int*/ axis;\n\n    var/*css_node_t**/ firstAbsoluteChild = null;\n    var/*css_node_t**/ currentAbsoluteChild = null;\n\n    var/*float*/ definedMainDim = CSS_UNDEFINED;\n    if (isMainDimDefined) {\n      definedMainDim = node.layout[dim[mainAxis]] - paddingAndBorderAxisMain;\n    }\n\n    // We want to execute the next two loops one per line with flex-wrap\n    var/*int*/ startLine = 0;\n    var/*int*/ endLine = 0;\n    // var/*int*/ nextOffset = 0;\n    var/*int*/ alreadyComputedNextLayout = 0;\n    // We aggregate the total dimensions of the container in those two variables\n    var/*float*/ linesCrossDim = 0;\n    var/*float*/ linesMainDim = 0;\n    var/*int*/ linesCount = 0;\n    while (endLine < childCount) {\n      // <Loop A> Layout non flexible children and count children by type\n\n      // mainContentDim is accumulation of the dimensions and margin of all the\n      // non flexible children. This will be used in order to either set the\n      // dimensions of the node if none already exist, or to compute the\n      // remaining space left for the flexible children.\n      var/*float*/ mainContentDim = 0;\n\n      // There are three kind of children, non flexible, flexible and absolute.\n      // We need to know how many there are in order to distribute the space.\n      var/*int*/ flexibleChildrenCount = 0;\n      var/*float*/ totalFlexible = 0;\n      var/*int*/ nonFlexibleChildrenCount = 0;\n\n      // Use the line loop to position children in the main axis for as long\n      // as they are using a simple stacking behaviour. Children that are\n      // immediately stacked in the initial loop will not be touched again\n      // in <Loop C>.\n      var/*bool*/ isSimpleStackMain =\n          (isMainDimDefined && justifyContent === CSS_JUSTIFY_FLEX_START) ||\n          (!isMainDimDefined && justifyContent !== CSS_JUSTIFY_CENTER);\n      var/*int*/ firstComplexMain = (isSimpleStackMain ? childCount : startLine);\n\n      // Use the initial line loop to position children in the cross axis for\n      // as long as they are relatively positioned with alignment STRETCH or\n      // FLEX_START. Children that are immediately stacked in the initial loop\n      // will not be touched again in <Loop D>.\n      var/*bool*/ isSimpleStackCross = true;\n      var/*int*/ firstComplexCross = childCount;\n\n      var/*css_node_t**/ firstFlexChild = null;\n      var/*css_node_t**/ currentFlexChild = null;\n\n      var/*float*/ mainDim = leadingPaddingAndBorderMain;\n      var/*float*/ crossDim = 0;\n\n      var/*float*/ maxWidth;\n      for (i = startLine; i < childCount; ++i) {\n        child = node.children[i];\n        child.lineIndex = linesCount;\n\n        child.nextAbsoluteChild = null;\n        child.nextFlexChild = null;\n\n        var/*css_align_t*/ alignItem = getAlignItem(node, child);\n\n        // Pre-fill cross axis dimensions when the child is using stretch before\n        // we call the recursive layout pass\n        if (alignItem === CSS_ALIGN_STRETCH &&\n            getPositionType(child) === CSS_POSITION_RELATIVE &&\n            isCrossDimDefined &&\n            !isDimDefined(child, crossAxis)) {\n          child.layout[dim[crossAxis]] = fmaxf(\n            boundAxis(child, crossAxis, node.layout[dim[crossAxis]] -\n              paddingAndBorderAxisCross - getMarginAxis(child, crossAxis)),\n            // You never want to go smaller than padding\n            getPaddingAndBorderAxis(child, crossAxis)\n          );\n        } else if (getPositionType(child) === CSS_POSITION_ABSOLUTE) {\n          // Store a private linked list of absolutely positioned children\n          // so that we can efficiently traverse them later.\n          if (firstAbsoluteChild === null) {\n            firstAbsoluteChild = child;\n          }\n          if (currentAbsoluteChild !== null) {\n            currentAbsoluteChild.nextAbsoluteChild = child;\n          }\n          currentAbsoluteChild = child;\n\n          // Pre-fill dimensions when using absolute position and both offsets for the axis are defined (either both\n          // left and right or top and bottom).\n          for (ii = 0; ii < 2; ii++) {\n            axis = (ii !== 0) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;\n            if (!isUndefined(node.layout[dim[axis]]) &&\n                !isDimDefined(child, axis) &&\n                isPosDefined(child, leading[axis]) &&\n                isPosDefined(child, trailing[axis])) {\n              child.layout[dim[axis]] = fmaxf(\n                boundAxis(child, axis, node.layout[dim[axis]] -\n                  getPaddingAndBorderAxis(node, axis) -\n                  getMarginAxis(child, axis) -\n                  getPosition(child, leading[axis]) -\n                  getPosition(child, trailing[axis])),\n                // You never want to go smaller than padding\n                getPaddingAndBorderAxis(child, axis)\n              );\n            }\n          }\n        }\n\n        var/*float*/ nextContentDim = 0;\n\n        // It only makes sense to consider a child flexible if we have a computed\n        // dimension for the node.\n        if (isMainDimDefined && isFlex(child)) {\n          flexibleChildrenCount++;\n          totalFlexible += child.style.flex;\n\n          // Store a private linked list of flexible children so that we can\n          // efficiently traverse them later.\n          if (firstFlexChild === null) {\n            firstFlexChild = child;\n          }\n          if (currentFlexChild !== null) {\n            currentFlexChild.nextFlexChild = child;\n          }\n          currentFlexChild = child;\n\n          // Even if we don't know its exact size yet, we already know the padding,\n          // border and margin. We'll use this partial information, which represents\n          // the smallest possible size for the child, to compute the remaining\n          // available space.\n          nextContentDim = getPaddingAndBorderAxis(child, mainAxis) +\n            getMarginAxis(child, mainAxis);\n\n        } else {\n          maxWidth = CSS_UNDEFINED;\n          if (!isMainRowDirection) {\n            if (isDimDefined(node, resolvedRowAxis)) {\n              maxWidth = node.layout[dim[resolvedRowAxis]] -\n                paddingAndBorderAxisResolvedRow;\n            } else {\n              maxWidth = parentMaxWidth -\n                getMarginAxis(node, resolvedRowAxis) -\n                paddingAndBorderAxisResolvedRow;\n            }\n          }\n\n          // This is the main recursive call. We layout non flexible children.\n          if (alreadyComputedNextLayout === 0) {\n            layoutNode(/*(java)!layoutContext, */child, maxWidth, direction);\n          }\n\n          // Absolute positioned elements do not take part of the layout, so we\n          // don't use them to compute mainContentDim\n          if (getPositionType(child) === CSS_POSITION_RELATIVE) {\n            nonFlexibleChildrenCount++;\n            // At this point we know the final size and margin of the element.\n            nextContentDim = getDimWithMargin(child, mainAxis);\n          }\n        }\n\n        // The element we are about to add would make us go to the next line\n        if (isNodeFlexWrap &&\n            isMainDimDefined &&\n            mainContentDim + nextContentDim > definedMainDim &&\n            // If there's only one element, then it's bigger than the content\n            // and needs its own line\n            i !== startLine) {\n          nonFlexibleChildrenCount--;\n          alreadyComputedNextLayout = 1;\n          break;\n        }\n\n        // Disable simple stacking in the main axis for the current line as\n        // we found a non-trivial child. The remaining children will be laid out\n        // in <Loop C>.\n        if (isSimpleStackMain &&\n            (getPositionType(child) !== CSS_POSITION_RELATIVE || isFlex(child))) {\n          isSimpleStackMain = false;\n          firstComplexMain = i;\n        }\n\n        // Disable simple stacking in the cross axis for the current line as\n        // we found a non-trivial child. The remaining children will be laid out\n        // in <Loop D>.\n        if (isSimpleStackCross &&\n            (getPositionType(child) !== CSS_POSITION_RELATIVE ||\n                (alignItem !== CSS_ALIGN_STRETCH && alignItem !== CSS_ALIGN_FLEX_START) ||\n                isUndefined(child.layout[dim[crossAxis]]))) {\n          isSimpleStackCross = false;\n          firstComplexCross = i;\n        }\n\n        if (isSimpleStackMain) {\n          child.layout[pos[mainAxis]] += mainDim;\n          if (isMainDimDefined) {\n            setTrailingPosition(node, child, mainAxis);\n          }\n\n          mainDim += getDimWithMargin(child, mainAxis);\n          crossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));\n        }\n\n        if (isSimpleStackCross) {\n          child.layout[pos[crossAxis]] += linesCrossDim + leadingPaddingAndBorderCross;\n          if (isCrossDimDefined) {\n            setTrailingPosition(node, child, crossAxis);\n          }\n        }\n\n        alreadyComputedNextLayout = 0;\n        mainContentDim += nextContentDim;\n        endLine = i + 1;\n      }\n\n      // <Loop B> Layout flexible children and allocate empty space\n\n      // In order to position the elements in the main axis, we have two\n      // controls. The space between the beginning and the first element\n      // and the space between each two elements.\n      var/*float*/ leadingMainDim = 0;\n      var/*float*/ betweenMainDim = 0;\n\n      // The remaining available space that needs to be allocated\n      var/*float*/ remainingMainDim = 0;\n      if (isMainDimDefined) {\n        remainingMainDim = definedMainDim - mainContentDim;\n      } else {\n        remainingMainDim = fmaxf(mainContentDim, 0) - mainContentDim;\n      }\n\n      // If there are flexible children in the mix, they are going to fill the\n      // remaining space\n      if (flexibleChildrenCount !== 0) {\n        var/*float*/ flexibleMainDim = remainingMainDim / totalFlexible;\n        var/*float*/ baseMainDim;\n        var/*float*/ boundMainDim;\n\n        // If the flex share of remaining space doesn't meet min/max bounds,\n        // remove this child from flex calculations.\n        currentFlexChild = firstFlexChild;\n        while (currentFlexChild !== null) {\n          baseMainDim = flexibleMainDim * currentFlexChild.style.flex +\n              getPaddingAndBorderAxis(currentFlexChild, mainAxis);\n          boundMainDim = boundAxis(currentFlexChild, mainAxis, baseMainDim);\n\n          if (baseMainDim !== boundMainDim) {\n            remainingMainDim -= boundMainDim;\n            totalFlexible -= currentFlexChild.style.flex;\n          }\n\n          currentFlexChild = currentFlexChild.nextFlexChild;\n        }\n        flexibleMainDim = remainingMainDim / totalFlexible;\n\n        // The non flexible children can overflow the container, in this case\n        // we should just assume that there is no space available.\n        if (flexibleMainDim < 0) {\n          flexibleMainDim = 0;\n        }\n\n        currentFlexChild = firstFlexChild;\n        while (currentFlexChild !== null) {\n          // At this point we know the final size of the element in the main\n          // dimension\n          currentFlexChild.layout[dim[mainAxis]] = boundAxis(currentFlexChild, mainAxis,\n            flexibleMainDim * currentFlexChild.style.flex +\n                getPaddingAndBorderAxis(currentFlexChild, mainAxis)\n          );\n\n          maxWidth = CSS_UNDEFINED;\n          if (isDimDefined(node, resolvedRowAxis)) {\n            maxWidth = node.layout[dim[resolvedRowAxis]] -\n              paddingAndBorderAxisResolvedRow;\n          } else if (!isMainRowDirection) {\n            maxWidth = parentMaxWidth -\n              getMarginAxis(node, resolvedRowAxis) -\n              paddingAndBorderAxisResolvedRow;\n          }\n\n          // And we recursively call the layout algorithm for this child\n          layoutNode(/*(java)!layoutContext, */currentFlexChild, maxWidth, direction);\n\n          child = currentFlexChild;\n          currentFlexChild = currentFlexChild.nextFlexChild;\n          child.nextFlexChild = null;\n        }\n\n      // We use justifyContent to figure out how to allocate the remaining\n      // space available\n      } else if (justifyContent !== CSS_JUSTIFY_FLEX_START) {\n        if (justifyContent === CSS_JUSTIFY_CENTER) {\n          leadingMainDim = remainingMainDim / 2;\n        } else if (justifyContent === CSS_JUSTIFY_FLEX_END) {\n          leadingMainDim = remainingMainDim;\n        } else if (justifyContent === CSS_JUSTIFY_SPACE_BETWEEN) {\n          remainingMainDim = fmaxf(remainingMainDim, 0);\n          if (flexibleChildrenCount + nonFlexibleChildrenCount - 1 !== 0) {\n            betweenMainDim = remainingMainDim /\n              (flexibleChildrenCount + nonFlexibleChildrenCount - 1);\n          } else {\n            betweenMainDim = 0;\n          }\n        } else if (justifyContent === CSS_JUSTIFY_SPACE_AROUND) {\n          // Space on the edges is half of the space between elements\n          betweenMainDim = remainingMainDim /\n            (flexibleChildrenCount + nonFlexibleChildrenCount);\n          leadingMainDim = betweenMainDim / 2;\n        }\n      }\n\n      // <Loop C> Position elements in the main axis and compute dimensions\n\n      // At this point, all the children have their dimensions set. We need to\n      // find their position. In order to do that, we accumulate data in\n      // variables that are also useful to compute the total dimensions of the\n      // container!\n      mainDim += leadingMainDim;\n\n      for (i = firstComplexMain; i < endLine; ++i) {\n        child = node.children[i];\n\n        if (getPositionType(child) === CSS_POSITION_ABSOLUTE &&\n            isPosDefined(child, leading[mainAxis])) {\n          // In case the child is position absolute and has left/top being\n          // defined, we override the position to whatever the user said\n          // (and margin/border).\n          child.layout[pos[mainAxis]] = getPosition(child, leading[mainAxis]) +\n            getLeadingBorder(node, mainAxis) +\n            getLeadingMargin(child, mainAxis);\n        } else {\n          // If the child is position absolute (without top/left) or relative,\n          // we put it at the current accumulated offset.\n          child.layout[pos[mainAxis]] += mainDim;\n\n          // Define the trailing position accordingly.\n          if (isMainDimDefined) {\n            setTrailingPosition(node, child, mainAxis);\n          }\n\n          // Now that we placed the element, we need to update the variables\n          // We only need to do that for relative elements. Absolute elements\n          // do not take part in that phase.\n          if (getPositionType(child) === CSS_POSITION_RELATIVE) {\n            // The main dimension is the sum of all the elements dimension plus\n            // the spacing.\n            mainDim += betweenMainDim + getDimWithMargin(child, mainAxis);\n            // The cross dimension is the max of the elements dimension since there\n            // can only be one element in that cross dimension.\n            crossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));\n          }\n        }\n      }\n\n      var/*float*/ containerCrossAxis = node.layout[dim[crossAxis]];\n      if (!isCrossDimDefined) {\n        containerCrossAxis = fmaxf(\n          // For the cross dim, we add both sides at the end because the value\n          // is aggregate via a max function. Intermediate negative values\n          // can mess this computation otherwise\n          boundAxis(node, crossAxis, crossDim + paddingAndBorderAxisCross),\n          paddingAndBorderAxisCross\n        );\n      }\n\n      // <Loop D> Position elements in the cross axis\n      for (i = firstComplexCross; i < endLine; ++i) {\n        child = node.children[i];\n\n        if (getPositionType(child) === CSS_POSITION_ABSOLUTE &&\n            isPosDefined(child, leading[crossAxis])) {\n          // In case the child is absolutely positionned and has a\n          // top/left/bottom/right being set, we override all the previously\n          // computed positions to set it correctly.\n          child.layout[pos[crossAxis]] = getPosition(child, leading[crossAxis]) +\n            getLeadingBorder(node, crossAxis) +\n            getLeadingMargin(child, crossAxis);\n\n        } else {\n          var/*float*/ leadingCrossDim = leadingPaddingAndBorderCross;\n\n          // For a relative children, we're either using alignItems (parent) or\n          // alignSelf (child) in order to determine the position in the cross axis\n          if (getPositionType(child) === CSS_POSITION_RELATIVE) {\n            /*eslint-disable */\n            // This variable is intentionally re-defined as the code is transpiled to a block scope language\n            var/*css_align_t*/ alignItem = getAlignItem(node, child);\n            /*eslint-enable */\n            if (alignItem === CSS_ALIGN_STRETCH) {\n              // You can only stretch if the dimension has not already been set\n              // previously.\n              if (isUndefined(child.layout[dim[crossAxis]])) {\n                child.layout[dim[crossAxis]] = fmaxf(\n                  boundAxis(child, crossAxis, containerCrossAxis -\n                    paddingAndBorderAxisCross - getMarginAxis(child, crossAxis)),\n                  // You never want to go smaller than padding\n                  getPaddingAndBorderAxis(child, crossAxis)\n                );\n              }\n            } else if (alignItem !== CSS_ALIGN_FLEX_START) {\n              // The remaining space between the parent dimensions+padding and child\n              // dimensions+margin.\n              var/*float*/ remainingCrossDim = containerCrossAxis -\n                paddingAndBorderAxisCross - getDimWithMargin(child, crossAxis);\n\n              if (alignItem === CSS_ALIGN_CENTER) {\n                leadingCrossDim += remainingCrossDim / 2;\n              } else { // CSS_ALIGN_FLEX_END\n                leadingCrossDim += remainingCrossDim;\n              }\n            }\n          }\n\n          // And we apply the position\n          child.layout[pos[crossAxis]] += linesCrossDim + leadingCrossDim;\n\n          // Define the trailing position accordingly.\n          if (isCrossDimDefined) {\n            setTrailingPosition(node, child, crossAxis);\n          }\n        }\n      }\n\n      linesCrossDim += crossDim;\n      linesMainDim = fmaxf(linesMainDim, mainDim);\n      linesCount += 1;\n      startLine = endLine;\n    }\n\n    // <Loop E>\n    //\n    // Note(prenaux): More than one line, we need to layout the crossAxis\n    // according to alignContent.\n    //\n    // Note that we could probably remove <Loop D> and handle the one line case\n    // here too, but for the moment this is safer since it won't interfere with\n    // previously working code.\n    //\n    // See specs:\n    // http://www.w3.org/TR/2012/CR-css3-flexbox-20120918/#layout-algorithm\n    // section 9.4\n    //\n    if (linesCount > 1 && isCrossDimDefined) {\n      var/*float*/ nodeCrossAxisInnerSize = node.layout[dim[crossAxis]] -\n          paddingAndBorderAxisCross;\n      var/*float*/ remainingAlignContentDim = nodeCrossAxisInnerSize - linesCrossDim;\n\n      var/*float*/ crossDimLead = 0;\n      var/*float*/ currentLead = leadingPaddingAndBorderCross;\n\n      var/*css_align_t*/ alignContent = getAlignContent(node);\n      if (alignContent === CSS_ALIGN_FLEX_END) {\n        currentLead += remainingAlignContentDim;\n      } else if (alignContent === CSS_ALIGN_CENTER) {\n        currentLead += remainingAlignContentDim / 2;\n      } else if (alignContent === CSS_ALIGN_STRETCH) {\n        if (nodeCrossAxisInnerSize > linesCrossDim) {\n          crossDimLead = (remainingAlignContentDim / linesCount);\n        }\n      }\n\n      var/*int*/ endIndex = 0;\n      for (i = 0; i < linesCount; ++i) {\n        var/*int*/ startIndex = endIndex;\n\n        // compute the line's height and find the endIndex\n        var/*float*/ lineHeight = 0;\n        for (ii = startIndex; ii < childCount; ++ii) {\n          child = node.children[ii];\n          if (getPositionType(child) !== CSS_POSITION_RELATIVE) {\n            continue;\n          }\n          if (child.lineIndex !== i) {\n            break;\n          }\n          if (!isUndefined(child.layout[dim[crossAxis]])) {\n            lineHeight = fmaxf(\n              lineHeight,\n              child.layout[dim[crossAxis]] + getMarginAxis(child, crossAxis)\n            );\n          }\n        }\n        endIndex = ii;\n        lineHeight += crossDimLead;\n\n        for (ii = startIndex; ii < endIndex; ++ii) {\n          child = node.children[ii];\n          if (getPositionType(child) !== CSS_POSITION_RELATIVE) {\n            continue;\n          }\n\n          var/*css_align_t*/ alignContentAlignItem = getAlignItem(node, child);\n          if (alignContentAlignItem === CSS_ALIGN_FLEX_START) {\n            child.layout[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n          } else if (alignContentAlignItem === CSS_ALIGN_FLEX_END) {\n            child.layout[pos[crossAxis]] = currentLead + lineHeight - getTrailingMargin(child, crossAxis) - child.layout[dim[crossAxis]];\n          } else if (alignContentAlignItem === CSS_ALIGN_CENTER) {\n            var/*float*/ childHeight = child.layout[dim[crossAxis]];\n            child.layout[pos[crossAxis]] = currentLead + (lineHeight - childHeight) / 2;\n          } else if (alignContentAlignItem === CSS_ALIGN_STRETCH) {\n            child.layout[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n            // TODO(prenaux): Correctly set the height of items with undefined\n            //                (auto) crossAxis dimension.\n          }\n        }\n\n        currentLead += lineHeight;\n      }\n    }\n\n    var/*bool*/ needsMainTrailingPos = false;\n    var/*bool*/ needsCrossTrailingPos = false;\n\n    // If the user didn't specify a width or height, and it has not been set\n    // by the container, then we set it via the children.\n    if (!isMainDimDefined) {\n      node.layout[dim[mainAxis]] = fmaxf(\n        // We're missing the last padding at this point to get the final\n        // dimension\n        boundAxis(node, mainAxis, linesMainDim + getTrailingPaddingAndBorder(node, mainAxis)),\n        // We can never assign a width smaller than the padding and borders\n        paddingAndBorderAxisMain\n      );\n\n      if (mainAxis === CSS_FLEX_DIRECTION_ROW_REVERSE ||\n          mainAxis === CSS_FLEX_DIRECTION_COLUMN_REVERSE) {\n        needsMainTrailingPos = true;\n      }\n    }\n\n    if (!isCrossDimDefined) {\n      node.layout[dim[crossAxis]] = fmaxf(\n        // For the cross dim, we add both sides at the end because the value\n        // is aggregate via a max function. Intermediate negative values\n        // can mess this computation otherwise\n        boundAxis(node, crossAxis, linesCrossDim + paddingAndBorderAxisCross),\n        paddingAndBorderAxisCross\n      );\n\n      if (crossAxis === CSS_FLEX_DIRECTION_ROW_REVERSE ||\n          crossAxis === CSS_FLEX_DIRECTION_COLUMN_REVERSE) {\n        needsCrossTrailingPos = true;\n      }\n    }\n\n    // <Loop F> Set trailing position if necessary\n    if (needsMainTrailingPos || needsCrossTrailingPos) {\n      for (i = 0; i < childCount; ++i) {\n        child = node.children[i];\n\n        if (needsMainTrailingPos) {\n          setTrailingPosition(node, child, mainAxis);\n        }\n\n        if (needsCrossTrailingPos) {\n          setTrailingPosition(node, child, crossAxis);\n        }\n      }\n    }\n\n    // <Loop G> Calculate dimensions for absolutely positioned elements\n    currentAbsoluteChild = firstAbsoluteChild;\n    while (currentAbsoluteChild !== null) {\n      // Pre-fill dimensions when using absolute position and both offsets for\n      // the axis are defined (either both left and right or top and bottom).\n      for (ii = 0; ii < 2; ii++) {\n        axis = (ii !== 0) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;\n\n        if (!isUndefined(node.layout[dim[axis]]) &&\n            !isDimDefined(currentAbsoluteChild, axis) &&\n            isPosDefined(currentAbsoluteChild, leading[axis]) &&\n            isPosDefined(currentAbsoluteChild, trailing[axis])) {\n          currentAbsoluteChild.layout[dim[axis]] = fmaxf(\n            boundAxis(currentAbsoluteChild, axis, node.layout[dim[axis]] -\n              getBorderAxis(node, axis) -\n              getMarginAxis(currentAbsoluteChild, axis) -\n              getPosition(currentAbsoluteChild, leading[axis]) -\n              getPosition(currentAbsoluteChild, trailing[axis])\n            ),\n            // You never want to go smaller than padding\n            getPaddingAndBorderAxis(currentAbsoluteChild, axis)\n          );\n        }\n\n        if (isPosDefined(currentAbsoluteChild, trailing[axis]) &&\n            !isPosDefined(currentAbsoluteChild, leading[axis])) {\n          currentAbsoluteChild.layout[leading[axis]] =\n            node.layout[dim[axis]] -\n            currentAbsoluteChild.layout[dim[axis]] -\n            getPosition(currentAbsoluteChild, trailing[axis]);\n        }\n      }\n\n      child = currentAbsoluteChild;\n      currentAbsoluteChild = currentAbsoluteChild.nextAbsoluteChild;\n      child.nextAbsoluteChild = null;\n    }\n  }\n\n  function layoutNode(node, parentMaxWidth, parentDirection) {\n    node.shouldUpdate = true;\n\n    var direction = node.style.direction || CSS_DIRECTION_LTR;\n    var skipLayout =\n      !node.isDirty &&\n      node.lastLayout &&\n      node.lastLayout.requestedHeight === node.layout.height &&\n      node.lastLayout.requestedWidth === node.layout.width &&\n      node.lastLayout.parentMaxWidth === parentMaxWidth &&\n      node.lastLayout.direction === direction;\n\n    if (skipLayout) {\n      node.layout.width = node.lastLayout.width;\n      node.layout.height = node.lastLayout.height;\n      node.layout.top = node.lastLayout.top;\n      node.layout.left = node.lastLayout.left;\n    } else {\n      if (!node.lastLayout) {\n        node.lastLayout = {};\n      }\n\n      node.lastLayout.requestedWidth = node.layout.width;\n      node.lastLayout.requestedHeight = node.layout.height;\n      node.lastLayout.parentMaxWidth = parentMaxWidth;\n      node.lastLayout.direction = direction;\n\n      // Reset child layouts\n      node.children.forEach(function(child) {\n        child.layout.width = undefined;\n        child.layout.height = undefined;\n        child.layout.top = 0;\n        child.layout.left = 0;\n      });\n\n      layoutNodeImpl(node, parentMaxWidth, parentDirection);\n\n      node.lastLayout.width = node.layout.width;\n      node.lastLayout.height = node.layout.height;\n      node.lastLayout.top = node.layout.top;\n      node.lastLayout.left = node.layout.left;\n    }\n  }\n\n  return {\n    layoutNodeImpl: layoutNodeImpl,\n    computeLayout: layoutNode,\n    fillNodes: fillNodes\n  };\n})();\n\n// This module export is only used for the purposes of unit testing this file. When\n// the library is packaged this file is included within css-layout.js which forms\n// the public API.\nif (typeof exports === 'object') {\n  module.exports = computeLayout;\n}\n\n\n  return function(node) {\n    /*eslint-disable */\n    // disabling ESLint because this code relies on the above include\n    computeLayout.fillNodes(node);\n    computeLayout.computeLayout(node);\n    /*eslint-enable */\n  };\n}));\n","/home/travis/build/npmtest/node-npmtest-css-layout/node_modules/css-layout/Gruntfile.js":"'use strict';\n\nmodule.exports = function(grunt) {\n  var path = require('path');\n  var isWindows = (/^win/).test(process.platform);\n\n  require('load-grunt-tasks')(grunt);\n\n  // config\n  var config = {\n    delimiter: path.delimiter,\n    libName: 'css-layout',\n    distFolder: 'dist',\n    srcFolder: 'src',\n    testFolder: 'src/__tests__',\n    javaLibFolder: 'src/java/lib',\n    javaSource: 'src/java/tests/com/facebook/csslayout/*.java',\n    javaTestFiles: 'org.junit.runner.JUnitCore com.facebook.csslayout.LayoutEngineTest com.facebook.csslayout.LayoutCachingTest com.facebook.csslayout.CSSNodeTest'\n  };\n\n  // C compilation configuration\n  if (isWindows) {\n    // Windows build, assumes cl is in the path (see https://msdn.microsoft.com/en-us/library/f2ccy3wt.aspx).\n    config.cTestOutput = 'c_test.exe';\n    config.cTestCompile = 'cl -nologo -Zi -Tpsrc/__tests__/Layout-test.c -Tpsrc/Layout.c -Tpsrc/Layout-test-utils.c -link -incremental:no -out:\"<%= config.cTestOutput %>\"';\n    config.cTestExecute = '<%= config.cTestOutput %>';\n    config.cTestClean = ['<%= config.cTestOutput %>', '*.obj', '*.pdb'];\n  } else {\n    // GCC build (OSX, Linux, ...), assumes gcc is in the path.\n    config.cTestOutput = 'c_test';\n    config.cTestCompile = 'gcc -std=c99 -Werror -Wno-padded src/__tests__/Layout-test.c src/Layout.c src/Layout-test-utils.c -lm -o \"./<%= config.cTestOutput %>\"';\n    config.cTestExecute = './<%= config.cTestOutput %>';\n    config.cTestClean = ['<%= config.cTestOutput %>'];\n  }\n\n  grunt.initConfig({\n    config: config,\n\n    mkdir: {\n      dist: {\n        options: {\n          create: ['<%= config.distFolder %>']\n        }\n      }\n    },\n\n    clean: {\n      dist: ['<%= config.distFolder %>/css-layout.*'],\n      cTest: config.cTestClean,\n      javaTest: ['**/*.class']\n    },\n\n    eslint: {\n      options: {\n        configFile: '.eslintrc'\n      },\n      target: ['<%= config.srcFolder %>/**/*.js', './Gruntfile.js']\n    },\n\n    includereplace: {\n      options: {\n        prefix: '// @@'\n      },\n      main: {\n        src: '<%= config.srcFolder %>/<%= config.libName %>.js',\n        dest: '<%= config.distFolder %>/<%= config.libName %>.js'\n      }\n    },\n\n    uglify: {\n      options: {\n        sourceMap: true,\n        sourceMapIncludeSources: true\n      },\n      main: {\n        files: {\n          '<%= config.distFolder %>/<%= config.libName %>.min.js':\n            ['<%= config.distFolder %>/<%= config.libName %>.js']\n        }\n      }\n    },\n\n    karma: {\n      main: {\n        options: {\n          files: [\n            '<%= config.srcFolder %>/Layout.js',\n            '<%= config.srcFolder %>/Layout-test-utils.js',\n            '<%= config.testFolder %>/Layout-test.js',\n            '<%= config.testFolder %>/Layout-consts-test.js'\n          ],\n          browsers: ['Chrome'],\n          frameworks: ['jasmine'],\n          singleRun: true\n        }\n      }\n    },\n\n    execute: {\n      transpile: {\n        src: ['<%= config.srcFolder %>/transpile.js']\n      }\n    },\n\n    concat: {\n      options: {\n        separator: '\\n',\n        // Replace all 'use strict' statements in the code with a single one at the top\n        banner: [\n          '/*',\n          ' * #define CSS_LAYOUT_IMPLEMENTATION',\n          ' * before you include this file in *one* C or C++ file to create the implementation.',\n          ' */\\n'\n        ].join('\\n'),\n        process: function(src, filepath) {\n          if (path.extname(filepath) === '.c') {\n            return [\n              '#ifdef CSS_LAYOUT_IMPLEMENTATION',\n              src,\n              '#endif // CSS_LAYOUT_IMPLEMENTATION'\n            ].join('\\n');\n          } else {\n            return src;\n          }\n        }\n      },\n      dist: {\n        src: ['<%= config.srcFolder %>/Layout.h', '<%= config.srcFolder %>/Layout.c'],\n        dest: '<%= config.distFolder %>/css-layout.h'\n      }\n    },\n\n    shell: {\n      cCompile: {\n        command: config.cTestCompile\n      },\n      cTestExecute: {\n        command: config.cTestExecute\n      },\n      javaCompile: {\n        command: 'javac -cp <%= config.javaLibFolder %>/junit4.jar<%= config.delimiter %><%= config.javaLibFolder %>/jsr305.jar<%= config.delimiter %><%= config.javaLibFolder %>/infer-annotations-1.4.jar' + ' -sourcepath ./src/java/src<%= config.delimiter %>./src/java/tests' + ' <%= config.javaSource %>'\n      },\n      javaTestExecute: {\n        command: 'java -cp ./src/java/src<%= config.delimiter %>./src/java/tests<%= config.delimiter %><%= config.javaLibFolder %>/junit4.jar<%= config.delimiter %><%= config.javaLibFolder %>/infer-annotations-1.4.jar <%= config.javaTestFiles %>'\n      },\n      javaPackage: {\n        command: 'jar cf <%= config.distFolder %>/<%= config.libName %>.jar <%= config.javaSource %>'\n      }\n    },\n\n    watch: {\n      files: ['src/Layout.js'],\n      tasks: ['ci']\n    }\n  });\n\n  // Compiles and runs the Java tests\n  grunt.registerTask('test-java', ['shell:javaCompile', 'shell:javaTestExecute', 'clean:javaTest']);\n\n  // Compiles and runs the C tests\n  grunt.registerTask('test-c', ['shell:cCompile', 'shell:cTestExecute', 'clean:cTest']);\n\n  // Transpiles the JavaScript to C and Java, running tests\n  grunt.registerTask('transpile', ['execute:transpile', 'test-c', 'test-java']);\n\n  // Lints and tests the JavaScritp using Chrome\n  grunt.registerTask('test-javascript', ['eslint', 'karma']);\n\n  // Packages the JavaScript as a single UMD module and minifies\n  grunt.registerTask('package-javascript', ['includereplace', 'uglify']);\n\n  // Packages the Java as a JAR\n  grunt.registerTask('package-java', ['shell:javaPackage']);\n\n  // Packages the C code as a single header\n  grunt.registerTask('package-c', ['concat']);\n\n  // package all languages\n  grunt.registerTask('package-all', ['package-javascript', 'package-java', 'package-c']);\n\n  // Default build, performs the full works!\n  grunt.registerTask('build', ['test-javascript', 'transpile', 'clean:dist', 'mkdir:dist', 'package-all']);\n\n  // The JavaScript unit tests require Chrome (they need a faithful flexbox implementation\n  // to test against), so under CI this step is skipped.\n  grunt.registerTask('ci', ['eslint', 'transpile', 'clean:dist', 'mkdir:dist', 'package-all']);\n\n  grunt.registerTask('default', ['build']);\n};\n","/home/travis/build/npmtest/node-npmtest-css-layout/node_modules/css-layout/src/CSharpTranspiler.js":"/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\nfunction __transpileToCSharpCommon(code) {\n  return code\n    .replace(/CSS_UNDEFINED/g, 'CSSConstants.UNDEFINED')\n    .replace(/CSS_JUSTIFY_/g, 'CSSJustify.')\n    .replace(/CSS_ALIGN_/g, 'CSSAlign.')\n    .replace(/CSS_POSITION_/g, 'CSSPositionType.')\n    .replace(/css_flex_direction_t/g, 'CSSFlexDirection')\n    .replace(/css_direction_t/g, 'CSSDirection')\n    .replace(/css_align_t/g, 'CSSAlign')\n    .replace(/css_justify_t/g, 'CSSJustify')\n    .replace(/css_dim_t/g, 'MeasureOutput')\n    .replace(/bool/g, 'boolean')\n    .replace(/style\\[dim/g, 'style.dimensions[dim')\n    .replace(/(style|layout)\\.width/g, '$1.dimensions[DIMENSION_WIDTH]')\n    .replace(/(style|layout)\\.height/g, '$1.dimensions[DIMENSION_HEIGHT]')\n    .replace(/layout\\[dim/g, 'layout.dimensions[dim')\n    .replace(/layout\\[pos/g, 'layout.position[pos')\n    .replace(/layout\\[leading/g, 'layout.position[leading')\n    .replace(/layout\\[trailing/g, 'layout.position[trailing')\n    .replace(/getPositionType\\((.+?)\\)/g, '$1.style.positionType')\n    .replace(/getJustifyContent\\((.+?)\\)/g, '$1.style.justifyContent')\n    .replace(/getAlignContent\\((.+?)\\)/g, '$1.style.alignContent')\n    .replace(/isPosDefined\\((.+?),\\s*(.+?)\\)/g, '!isUndefined\\($1.style.position[$2]\\)')\n    .replace(/isDimDefined\\((.+?),\\s*(.+?)\\)/g, '\\(!isUndefined\\($1.style.dimensions[dim[$2]]\\) && $1.style.dimensions[dim[$2]] >= 0.0\\)')\n    .replace(/getPosition\\((.+?),\\s*(.+?)\\)/g, '\\(isUndefined\\($1.style.position[$2]\\) ?  0 : $1.style.position[$2]\\)')\n    .replace(/setTrailingPosition\\((.+?),\\s*(.+?),\\s*(.+?)\\)/g, '$2.layout.position[trailing[$3]] = $1.layout.dimensions[dim[$3]] - $2.layout.dimensions[dim[$3]] - $2.layout.position[pos[$3]]')\n    .replace(/isFlex\\((.+?)\\)/g, '\\($1.style.positionType == CSSPositionType.RELATIVE && $1.style.flex > 0\\)')\n    .replace(/isFlexWrap\\((.+?)\\)/g, '\\($1.style.flexWrap == CSSWrap.WRAP\\)')\n    .replace(/getPaddingAndBorderAxis\\((.+?),\\s*(.+?)\\)/g, '\\(getLeadingPaddingAndBorder($1, $2) + getTrailingPaddingAndBorder($1, $2)\\)')\n    .replace(/getBorderAxis\\((.+?),\\s*(.+?)\\)/g, '\\(getLeadingBorder($1, $2) + getTrailingBorder($1, $2)\\)')\n    .replace(/getMarginAxis\\((.+?),\\s*(.+?)\\)/g, '\\(getLeadingMargin($1, $2) + getTrailingMargin($1, $2)\\)')\n    .replace(/getLeadingPaddingAndBorder\\((.+?),\\s*(.+?)\\)/g, '\\(getLeadingPadding($1, $2) + getLeadingBorder($1, $2)\\)')\n    .replace(/getTrailingPaddingAndBorder\\((.+?),\\s*(.+?)\\)/g, '\\(getTrailingPadding($1, $2) + getTrailingBorder($1, $2)\\)')\n    .replace(/getDimWithMargin\\((.+?),\\s*(.+?)\\)/g, '\\($1.layout.dimensions[dim[$2]] + getLeadingMargin($1, $2) + getTrailingMargin($1, $2)\\)')\n    .replace(/getLeadingMargin\\((.+?),\\s*(.+?)\\)/g, '$1.style.margin.getWithFallback(leadingSpacing[$2], leading[$2])')\n    .replace(/getTrailingMargin\\((.+?),\\s*(.+?)\\)/g, '$1.style.margin.getWithFallback(trailingSpacing[$2], trailing[$2])')\n    .replace(/getLeadingPadding\\((.+?),\\s*(.+?)\\)/g, '$1.style.padding.getWithFallback(leadingSpacing[$2], leading[$2])')\n    .replace(/getTrailingPadding\\((.+?),\\s*(.+?)\\)/g, '$1.style.padding.getWithFallback(trailingSpacing[$2], trailing[$2])')\n    .replace(/getLeadingBorder\\((.+?),\\s*(.+?)\\)/g, '$1.style.border.getWithFallback(leadingSpacing[$2], leading[$2])')\n    .replace(/getTrailingBorder\\((.+?),\\s*(.+?)\\)/g, '$1.style.border.getWithFallback(trailingSpacing[$2], trailing[$2])')\n    .replace(/isRowDirection\\((.+?)\\)/g, '\\($1 == CSS_FLEX_DIRECTION_ROW || $1 == CSS_FLEX_DIRECTION_ROW_REVERSE\\)')\n    .replace(/isUndefined\\((.+?)\\)/g, 'float.IsNaN\\($1\\)')\n    .replace(/\\/\\*\\(c\\)!([^*]+)\\*\\//g, '')\n    .replace(/var\\/\\*\\(java\\)!([^*]+)\\*\\//g, '$1')\n    .replace(/\\/\\*\\(java\\)!([^*]+)\\*\\//g, '$1')\n\n    // additional case conversions\n\n    .replace(/(CSSConstants|CSSWrap|CSSJustify|CSSAlign|CSSPositionType)\\.([_A-Z]+)/g,\n        function(str, match1, match2) {\n          return match1 + '.' + constantToPascalCase(match2);\n        });\n}\n\nfunction __transpileSingleTestToCSharp(code) {\n  return __transpileToCSharpCommon(code)\n .replace(/CSS_DIRECTION_/g, 'CSSDirection.')\n    .replace(/CSS_FLEX_DIRECTION_/g, 'CSSFlexDirection.')\n    .replace(/CSS_WRAP/g, 'CSSWrap.WRAP')\n    .replace(/new_test_css_node/g, 'new TestCSSNode')\n    .replace(// style.position[CSS_TOP] => style.position[CSSLayout.POSITION_TOP]\n        /(style|layout)\\.position\\[CSS_(LEFT|TOP|RIGHT|BOTTOM)\\]/g,\n        function(str, match1, match2) {\n          return match1 + '.position[POSITION_' + match2 + ']';\n        })\n    .replace(// style.dimensions[CSS_WIDTH] => style.dimensions[CSSLayout.DIMENSION_WIDTH]\n        /(style|layout)\\.dimensions\\[CSS_(WIDTH|HEIGHT)\\]/g,\n        function(str, match1, match2) {\n          return match1 + '.dimensions[DIMENSION_' + match2 + ']';\n        })\n    .replace(// style.maxDimensions[CSS_WIDTH] => style.maxWidth\n        /(style|layout)\\.maxDimensions\\[CSS_(WIDTH|HEIGHT)\\]/g,\n        function(str, match1, match2) {\n          return match1 + '.max' + match2.substr(0, 1).toUpperCase() + match2.substr(1).toLowerCase();\n        })\n    .replace(// style.minDimensions[CSS_WIDTH] => style.minWidth\n        /(style|layout)\\.minDimensions\\[CSS_(WIDTH|HEIGHT)\\]/g,\n        function(str, match1, match2) {\n          return match1 + '.min' + match2.substr(0, 1).toUpperCase() + match2.substr(1).toLowerCase();\n        })\n    .replace(// style.margin[CSS_TOP] = 12.3 => style.margin[Spacing.TOP].set(12.3)\n        /style\\.(margin|border|padding)\\[CSS_(TOP|BOTTOM|LEFT|RIGHT|START|END)\\]\\s+=\\s+(-?[\\.\\d]+)/g,\n        function(str, match1, match2, match3) {\n          var propertyCap = match1.charAt(0).toUpperCase() + match1.slice(1);\n          return 'set' + propertyCap + '(Spacing.' + match2 + ', ' + match3 + ')';\n        })\n    .replace(// style.margin[CSS_TOP] => style.margin[Spacing.TOP]\n        /style\\.(margin|border|padding)\\[CSS_(TOP|BOTTOM|LEFT|RIGHT|START|END)\\]/g,\n        function(str, match1, match2) {\n          return 'style.' + match1 + '.get(Spacing.' + match2 + ')';\n        })\n    .replace(/get_child\\(.*context\\,\\s([^\\)]+)\\)/g, 'getChildAt($1)')\n    .replace(/init_css_node_children/g, 'addChildren')\n    .replace(/css_node_t(\\s)\\*/g, 'TestCSSNode$1')\n    .replace(/\\->/g, '.')\n    .replace(/(\\d+\\.\\d+)/g, '$1f')\n    .replace(// style.flex_direction => style.flexDirection\n        /style\\.([^_\\[\\]\\s]+)_(\\w)(\\w+)/g,\n        function(str, match1, match2, match3) {\n          return 'style.' + match1 + match2.toUpperCase() + match3;\n        })\n    .replace(/(\\w+)\\.measure\\s+=\\s+.+/, '$1.setMeasureFunction(sTestMeasureFunction);')\n\n    // additional case conversions\n\n    .replace(/(CSSWrap|CSSFlexDirection)\\.([_A-Z]+)/g,\n        function(str, match1, match2) {\n          return match1 + '.' + constantToPascalCase(match2);\n        });\n}\n\nfunction indent(code) {\n  return code\n    .split('\\n')\n    .map(function(line) { return '    ' + line; })\n    .join('\\n');\n}\n\nfunction constantToPascalCase(str) {\n  return str[0] + str.substr(1)\n    .toLowerCase()\n    .replace(/_(.)/g,\n      function(_, m) { return m.toUpperCase(); });\n}\n\nvar CSharpTranspiler = {\n  transpileLayoutEngine: function(code) {\n    return indent(\n      __transpileToCSharpCommon(code)\n        .replace(/function\\s+layoutNode.*/, '')\n        .replace('node.style.measure', 'node.measure')\n        .replace(/\\.children\\.length/g, '.getChildCount()')\n        .replace(/node.children\\[i\\]/g, 'node.getChildAt(i)')\n        .replace(/node.children\\[ii\\]/g, 'node.getChildAt(ii)')\n        .replace(/fmaxf/g, 'Math.Max')\n        .replace(/\\/\\*\\([^\\/]+\\*\\/\\n/g, '') // remove comments for other languages\n        .replace(/var\\/\\*([^\\/]+)\\*\\//g, '$1')\n        .replace(/ === /g, ' == ')\n        .replace(/ !== /g, ' != ')\n        .replace(/\\n {2}/g, '\\n')\n        .replace(/\\/[*]!([^*]+)[*]\\//g, '$1')\n        .replace(/css_node_t\\*/g, 'CSSNode'));\n  },\n\n  transpileCConstDefs: function(cConstDefs) {\n    return indent(\n      cConstDefs\n        .replace(/#define\\s+(\\w+)\\s+(\\\"[^\\\"]+\\\")/g, 'public static readonly string $1 = $2;')\n        .replace(/#define\\s+(\\w+)\\s+(.+)/g, 'public static readonly float $1 = $2f;'));\n  },\n\n  transpileCTestsArray: function(allTestsInC) {\n    var allTestsInCSharp = [];\n    for (var i = 0; i < allTestsInC.length; i++) {\n      allTestsInCSharp[i] =\n          '    [Test]\\n' +\n          '    public void TestCase' + i + '()\\n' +\n          __transpileSingleTestToCSharp(allTestsInC[i]);\n    }\n    return allTestsInCSharp.join('\\n\\n');\n  }\n};\n\nif (typeof module !== 'undefined') {\n  module.exports = CSharpTranspiler;\n}\n","/home/travis/build/npmtest/node-npmtest-css-layout/node_modules/css-layout/src/css-layout.js":"// UMD (Universal Module Definition)\n// See https://github.com/umdjs/umd for reference\n//\n// This file uses the following specific UMD implementation:\n// https://github.com/umdjs/umd/blob/master/returnExports.js\n(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.computeLayout = factory();\n  }\n}(this, function() {\n  // @@include('./Layout.js')\n\n  return function(node) {\n    /*eslint-disable */\n    // disabling ESLint because this code relies on the above include\n    computeLayout.fillNodes(node);\n    computeLayout.computeLayout(node);\n    /*eslint-enable */\n  };\n}));\n","/home/travis/build/npmtest/node-npmtest-css-layout/node_modules/css-layout/src/JavaTranspiler.js":"/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\nfunction __transpileToJavaCommon(code) {\n  return code\n    .replace(/CSS_UNDEFINED/g, 'CSSConstants.UNDEFINED')\n    .replace(/CSS_JUSTIFY_/g, 'CSSJustify.')\n    .replace(/CSS_ALIGN_/g, 'CSSAlign.')\n    .replace(/CSS_POSITION_/g, 'CSSPositionType.')\n    .replace(/css_flex_direction_t/g, 'CSSFlexDirection')\n    .replace(/css_direction_t/g, 'CSSDirection')\n    .replace(/css_align_t/g, 'CSSAlign')\n    .replace(/css_justify_t/g, 'CSSJustify')\n    .replace(/css_dim_t/g, 'MeasureOutput')\n    .replace(/bool/g, 'boolean')\n    .replace(/style\\[dim/g, 'style.dimensions[dim')\n    .replace(/(style|layout)\\.width/g, '$1.dimensions[DIMENSION_WIDTH]')\n    .replace(/(style|layout)\\.height/g, '$1.dimensions[DIMENSION_HEIGHT]')\n    .replace(/layout\\[dim/g, 'layout.dimensions[dim')\n    .replace(/layout\\[pos/g, 'layout.position[pos')\n    .replace(/layout\\[leading/g, 'layout.position[leading')\n    .replace(/layout\\[trailing/g, 'layout.position[trailing')\n    .replace(/getPositionType\\((.+?)\\)/g, '$1.style.positionType')\n    .replace(/getJustifyContent\\((.+?)\\)/g, '$1.style.justifyContent')\n    .replace(/getAlignContent\\((.+?)\\)/g, '$1.style.alignContent')\n    .replace(/isPosDefined\\((.+?),\\s*(.+?)\\)/g, '!isUndefined\\($1.style.position[$2]\\)')\n    .replace(/isDimDefined\\((.+?),\\s*(.+?)\\)/g, '\\(!isUndefined\\($1.style.dimensions[dim[$2]]\\) && $1.style.dimensions[dim[$2]] >= 0.0\\)')\n    .replace(/getPosition\\((.+?),\\s*(.+?)\\)/g, '\\(isUndefined\\($1.style.position[$2]\\) ?  0 : $1.style.position[$2]\\)')\n    .replace(/setTrailingPosition\\((.+?),\\s*(.+?),\\s*(.+?)\\)/g, '$2.layout.position[trailing[$3]] = $1.layout.dimensions[dim[$3]] - $2.layout.dimensions[dim[$3]] - $2.layout.position[pos[$3]]')\n    .replace(/isFlex\\((.+?)\\)/g, '\\($1.style.positionType == CSSPositionType.RELATIVE && $1.style.flex > 0\\)')\n    .replace(/isFlexWrap\\((.+?)\\)/g, '\\($1.style.flexWrap == CSSWrap.WRAP\\)')\n    .replace(/getPaddingAndBorderAxis\\((.+?),\\s*(.+?)\\)/g, '\\(getLeadingPaddingAndBorder($1, $2) + getTrailingPaddingAndBorder($1, $2)\\)')\n    .replace(/getBorderAxis\\((.+?),\\s*(.+?)\\)/g, '\\(getLeadingBorder($1, $2) + getTrailingBorder($1, $2)\\)')\n    .replace(/getMarginAxis\\((.+?),\\s*(.+?)\\)/g, '\\(getLeadingMargin($1, $2) + getTrailingMargin($1, $2)\\)')\n    .replace(/getLeadingPaddingAndBorder\\((.+?),\\s*(.+?)\\)/g, '\\(getLeadingPadding($1, $2) + getLeadingBorder($1, $2)\\)')\n    .replace(/getTrailingPaddingAndBorder\\((.+?),\\s*(.+?)\\)/g, '\\(getTrailingPadding($1, $2) + getTrailingBorder($1, $2)\\)')\n    .replace(/getDimWithMargin\\((.+?),\\s*(.+?)\\)/g, '\\($1.layout.dimensions[dim[$2]] + getLeadingMargin($1, $2) + getTrailingMargin($1, $2)\\)')\n    .replace(/getLeadingMargin\\((.+?),\\s*(.+?)\\)/g, '$1.style.margin.getWithFallback(leadingSpacing[$2], leading[$2])')\n    .replace(/getTrailingMargin\\((.+?),\\s*(.+?)\\)/g, '$1.style.margin.getWithFallback(trailingSpacing[$2], trailing[$2])')\n    .replace(/getLeadingPadding\\((.+?),\\s*(.+?)\\)/g, '$1.style.padding.getWithFallback(leadingSpacing[$2], leading[$2])')\n    .replace(/getTrailingPadding\\((.+?),\\s*(.+?)\\)/g, '$1.style.padding.getWithFallback(trailingSpacing[$2], trailing[$2])')\n    .replace(/getLeadingBorder\\((.+?),\\s*(.+?)\\)/g, '$1.style.border.getWithFallback(leadingSpacing[$2], leading[$2])')\n    .replace(/getTrailingBorder\\((.+?),\\s*(.+?)\\)/g, '$1.style.border.getWithFallback(trailingSpacing[$2], trailing[$2])')\n    .replace(/isRowDirection\\((.+?)\\)/g, '\\($1 == CSS_FLEX_DIRECTION_ROW || $1 == CSS_FLEX_DIRECTION_ROW_REVERSE\\)')\n    .replace(/isUndefined\\((.+?)\\)/g, 'Float.isNaN\\($1\\)')\n    .replace(/\\/\\*\\(c\\)!([^*]+)\\*\\//g, '')\n    .replace(/var\\/\\*\\(java\\)!([^*]+)\\*\\//g, '$1')\n    .replace(/\\/\\*\\(java\\)!([^*]+)\\*\\//g, '$1');\n}\n\nfunction __transpileSingleTestToJava(code) {\n  return __transpileToJavaCommon(code)\n    .replace(/CSS_DIRECTION_/g, 'CSSDirection.')\n    .replace(/CSS_FLEX_DIRECTION_/g, 'CSSFlexDirection.')\n    .replace(/CSS_WRAP/g, 'CSSWrap.WRAP')\n    .replace(/new_test_css_node/g, 'new TestCSSNode')\n    .replace(// style.position[CSS_TOP] => style.position[CSSLayout.POSITION_TOP]\n        /(style|layout)\\.position\\[CSS_(LEFT|TOP|RIGHT|BOTTOM)\\]/g,\n        function(str, match1, match2) {\n          return match1 + '.position[POSITION_' + match2 + ']';\n        })\n    .replace(// style.dimensions[CSS_WIDTH] => style.dimensions[CSSLayout.DIMENSION_WIDTH]\n        /(style|layout)\\.dimensions\\[CSS_(WIDTH|HEIGHT)\\]/g,\n        function(str, match1, match2) {\n          return match1 + '.dimensions[DIMENSION_' + match2 + ']';\n        })\n    .replace(// style.maxDimensions[CSS_WIDTH] => style.maxWidth\n        /(style|layout)\\.maxDimensions\\[CSS_(WIDTH|HEIGHT)\\]/g,\n        function(str, match1, match2) {\n          return match1 + '.max' + match2.substr(0, 1).toUpperCase() + match2.substr(1).toLowerCase();\n        })\n    .replace(// style.minDimensions[CSS_WIDTH] => style.minWidth\n        /(style|layout)\\.minDimensions\\[CSS_(WIDTH|HEIGHT)\\]/g,\n        function(str, match1, match2) {\n          return match1 + '.min' + match2.substr(0, 1).toUpperCase() + match2.substr(1).toLowerCase();\n        })\n    .replace(// style.margin[CSS_TOP] = 12.3 => style.margin[Spacing.TOP].set(12.3)\n        /style\\.(margin|border|padding)\\[CSS_(TOP|BOTTOM|LEFT|RIGHT|START|END)\\]\\s+=\\s+(-?[\\.\\d]+)/g,\n        function(str, match1, match2, match3) {\n          var propertyCap = match1.charAt(0).toUpperCase() + match1.slice(1);\n          return 'set' + propertyCap + '(Spacing.' + match2 + ', ' + match3 + ')';\n        })\n    .replace(// style.margin[CSS_TOP] => style.margin[Spacing.TOP]\n        /style\\.(margin|border|padding)\\[CSS_(TOP|BOTTOM|LEFT|RIGHT|START|END)\\]/g,\n        function(str, match1, match2) {\n          return 'style.' + match1 + '.get(Spacing.' + match2 + ')';\n        })\n    .replace(/get_child\\(.*context\\,\\s([^\\)]+)\\)/g, 'getChildAt($1)')\n    .replace(/init_css_node_children/g, 'addChildren')\n    .replace(/css_node_t(\\s)\\*/g, 'TestCSSNode$1')\n    .replace(/\\->/g, '.')\n    .replace(/(\\d+\\.\\d+)/g, '$1f')\n    .replace(// style.flex_direction => style.flexDirection\n        /style\\.([^_\\[\\]\\s]+)_(\\w)(\\w+)/g,\n        function(str, match1, match2, match3) {\n          return 'style.' + match1 + match2.toUpperCase() + match3;\n        })\n    .replace(/(\\w+)\\.measure\\s+=\\s+.+/, '$1.setMeasureFunction(sTestMeasureFunction);');\n}\n\nfunction indent(code) {\n  return code\n    .split('\\n')\n    .map(function(line) { return '  ' + line; })\n    .join('\\n');\n}\n\nvar JavaTranspiler = {\n  transpileLayoutEngine: function(code) {\n    return indent(\n      __transpileToJavaCommon(code)\n        .replace(/function\\s+layoutNode.*/, '')\n        .replace('node.style.measure', 'node.measure')\n        .replace(/\\.children\\.length/g, '.getChildCount()')\n        .replace(/node.children\\[i\\]/g, 'node.getChildAt(i)')\n        .replace(/node.children\\[ii\\]/g, 'node.getChildAt(ii)')\n        .replace(/fmaxf/g, 'Math.max')\n        .replace(/\\/\\*\\([^\\/]+\\*\\/\\n/g, '') // remove comments for other languages\n        .replace(/var\\/\\*([^\\/]+)\\*\\//g, '$1')\n        .replace(/ === /g, ' == ')\n        .replace(/ !== /g, ' != ')\n        .replace(/\\n {2}/g, '\\n')\n        .replace(/\\/[*]!([^*]+)[*]\\//g, '$1')\n        .replace(/css_node_t\\*/g, 'CSSNode'));\n  },\n\n  transpileCConstDefs: function(cConstDefs) {\n    return indent(\n      cConstDefs\n        .replace(/#define\\s+(\\w+)\\s+(\\\"[^\\\"]+\\\")/g, 'public static final String $1 = $2;')\n        .replace(/#define\\s+(\\w+)\\s+(.+)/g, 'public static final float $1 = $2f;'));\n  },\n\n  transpileCTestsArray: function(allTestsInC) {\n    var allTestsInJava = [];\n    for (var i = 0; i < allTestsInC.length; i++) {\n      allTestsInJava[i] =\n          '  @Test\\n' +\n          '  public void testCase' + i + '()\\n' +\n          __transpileSingleTestToJava(allTestsInC[i]);\n    }\n    return allTestsInJava.join('\\n\\n');\n  }\n};\n\nif (typeof module !== 'undefined') {\n  module.exports = JavaTranspiler;\n}\n","/home/travis/build/npmtest/node-npmtest-css-layout/node_modules/css-layout/src/Layout.js":"/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\nvar computeLayout = (function() {\n\n  var CSS_UNDEFINED;\n\n  var CSS_DIRECTION_INHERIT = 'inherit';\n  var CSS_DIRECTION_LTR = 'ltr';\n  var CSS_DIRECTION_RTL = 'rtl';\n\n  var CSS_FLEX_DIRECTION_ROW = 'row';\n  var CSS_FLEX_DIRECTION_ROW_REVERSE = 'row-reverse';\n  var CSS_FLEX_DIRECTION_COLUMN = 'column';\n  var CSS_FLEX_DIRECTION_COLUMN_REVERSE = 'column-reverse';\n\n  var CSS_JUSTIFY_FLEX_START = 'flex-start';\n  var CSS_JUSTIFY_CENTER = 'center';\n  var CSS_JUSTIFY_FLEX_END = 'flex-end';\n  var CSS_JUSTIFY_SPACE_BETWEEN = 'space-between';\n  var CSS_JUSTIFY_SPACE_AROUND = 'space-around';\n\n  var CSS_ALIGN_FLEX_START = 'flex-start';\n  var CSS_ALIGN_CENTER = 'center';\n  var CSS_ALIGN_FLEX_END = 'flex-end';\n  var CSS_ALIGN_STRETCH = 'stretch';\n\n  var CSS_POSITION_RELATIVE = 'relative';\n  var CSS_POSITION_ABSOLUTE = 'absolute';\n\n  var leading = {\n    'row': 'left',\n    'row-reverse': 'right',\n    'column': 'top',\n    'column-reverse': 'bottom'\n  };\n  var trailing = {\n    'row': 'right',\n    'row-reverse': 'left',\n    'column': 'bottom',\n    'column-reverse': 'top'\n  };\n  var pos = {\n    'row': 'left',\n    'row-reverse': 'right',\n    'column': 'top',\n    'column-reverse': 'bottom'\n  };\n  var dim = {\n    'row': 'width',\n    'row-reverse': 'width',\n    'column': 'height',\n    'column-reverse': 'height'\n  };\n\n  // When transpiled to Java / C the node type has layout, children and style\n  // properties. For the JavaScript version this function adds these properties\n  // if they don't already exist.\n  function fillNodes(node) {\n    if (!node.layout || node.isDirty) {\n      node.layout = {\n        width: undefined,\n        height: undefined,\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0\n      };\n    }\n\n    if (!node.style) {\n      node.style = {};\n    }\n\n    if (!node.children) {\n      node.children = [];\n    }\n    node.children.forEach(fillNodes);\n    return node;\n  }\n\n  function isUndefined(value) {\n    return value === undefined;\n  }\n\n  function isRowDirection(flexDirection) {\n    return flexDirection === CSS_FLEX_DIRECTION_ROW ||\n           flexDirection === CSS_FLEX_DIRECTION_ROW_REVERSE;\n  }\n\n  function isColumnDirection(flexDirection) {\n    return flexDirection === CSS_FLEX_DIRECTION_COLUMN ||\n           flexDirection === CSS_FLEX_DIRECTION_COLUMN_REVERSE;\n  }\n\n  function getLeadingMargin(node, axis) {\n    if (node.style.marginStart !== undefined && isRowDirection(axis)) {\n      return node.style.marginStart;\n    }\n\n    var value = null;\n    switch (axis) {\n      case 'row':            value = node.style.marginLeft;   break;\n      case 'row-reverse':    value = node.style.marginRight;  break;\n      case 'column':         value = node.style.marginTop;    break;\n      case 'column-reverse': value = node.style.marginBottom; break;\n    }\n\n    if (value !== undefined) {\n      return value;\n    }\n\n    if (node.style.margin !== undefined) {\n      return node.style.margin;\n    }\n\n    return 0;\n  }\n\n  function getTrailingMargin(node, axis) {\n    if (node.style.marginEnd !== undefined && isRowDirection(axis)) {\n      return node.style.marginEnd;\n    }\n\n    var value = null;\n    switch (axis) {\n      case 'row':            value = node.style.marginRight;  break;\n      case 'row-reverse':    value = node.style.marginLeft;   break;\n      case 'column':         value = node.style.marginBottom; break;\n      case 'column-reverse': value = node.style.marginTop;    break;\n    }\n\n    if (value != null) {\n      return value;\n    }\n\n    if (node.style.margin !== undefined) {\n      return node.style.margin;\n    }\n\n    return 0;\n  }\n\n  function getLeadingPadding(node, axis) {\n    if (node.style.paddingStart !== undefined && node.style.paddingStart >= 0\n        && isRowDirection(axis)) {\n      return node.style.paddingStart;\n    }\n\n    var value = null;\n    switch (axis) {\n      case 'row':            value = node.style.paddingLeft;   break;\n      case 'row-reverse':    value = node.style.paddingRight;  break;\n      case 'column':         value = node.style.paddingTop;    break;\n      case 'column-reverse': value = node.style.paddingBottom; break;\n    }\n\n    if (value != null && value >= 0) {\n      return value;\n    }\n\n    if (node.style.padding !== undefined && node.style.padding >= 0) {\n      return node.style.padding;\n    }\n\n    return 0;\n  }\n\n  function getTrailingPadding(node, axis) {\n    if (node.style.paddingEnd !== undefined && node.style.paddingEnd >= 0\n        && isRowDirection(axis)) {\n      return node.style.paddingEnd;\n    }\n\n    var value = null;\n    switch (axis) {\n      case 'row':            value = node.style.paddingRight;  break;\n      case 'row-reverse':    value = node.style.paddingLeft;   break;\n      case 'column':         value = node.style.paddingBottom; break;\n      case 'column-reverse': value = node.style.paddingTop;    break;\n    }\n\n    if (value != null && value >= 0) {\n      return value;\n    }\n\n    if (node.style.padding !== undefined && node.style.padding >= 0) {\n      return node.style.padding;\n    }\n\n    return 0;\n  }\n\n  function getLeadingBorder(node, axis) {\n    if (node.style.borderStartWidth !== undefined && node.style.borderStartWidth >= 0\n        && isRowDirection(axis)) {\n      return node.style.borderStartWidth;\n    }\n\n    var value = null;\n    switch (axis) {\n      case 'row':            value = node.style.borderLeftWidth;   break;\n      case 'row-reverse':    value = node.style.borderRightWidth;  break;\n      case 'column':         value = node.style.borderTopWidth;    break;\n      case 'column-reverse': value = node.style.borderBottomWidth; break;\n    }\n\n    if (value != null && value >= 0) {\n      return value;\n    }\n\n    if (node.style.borderWidth !== undefined && node.style.borderWidth >= 0) {\n      return node.style.borderWidth;\n    }\n\n    return 0;\n  }\n\n  function getTrailingBorder(node, axis) {\n    if (node.style.borderEndWidth !== undefined && node.style.borderEndWidth >= 0\n        && isRowDirection(axis)) {\n      return node.style.borderEndWidth;\n    }\n\n    var value = null;\n    switch (axis) {\n      case 'row':            value = node.style.borderRightWidth;  break;\n      case 'row-reverse':    value = node.style.borderLeftWidth;   break;\n      case 'column':         value = node.style.borderBottomWidth; break;\n      case 'column-reverse': value = node.style.borderTopWidth;    break;\n    }\n\n    if (value != null && value >= 0) {\n      return value;\n    }\n\n    if (node.style.borderWidth !== undefined && node.style.borderWidth >= 0) {\n      return node.style.borderWidth;\n    }\n\n    return 0;\n  }\n\n  function getLeadingPaddingAndBorder(node, axis) {\n    return getLeadingPadding(node, axis) + getLeadingBorder(node, axis);\n  }\n\n  function getTrailingPaddingAndBorder(node, axis) {\n    return getTrailingPadding(node, axis) + getTrailingBorder(node, axis);\n  }\n\n  function getBorderAxis(node, axis) {\n    return getLeadingBorder(node, axis) + getTrailingBorder(node, axis);\n  }\n\n  function getMarginAxis(node, axis) {\n    return getLeadingMargin(node, axis) + getTrailingMargin(node, axis);\n  }\n\n  function getPaddingAndBorderAxis(node, axis) {\n    return getLeadingPaddingAndBorder(node, axis) +\n        getTrailingPaddingAndBorder(node, axis);\n  }\n\n  function getJustifyContent(node) {\n    if (node.style.justifyContent) {\n      return node.style.justifyContent;\n    }\n    return 'flex-start';\n  }\n\n  function getAlignContent(node) {\n    if (node.style.alignContent) {\n      return node.style.alignContent;\n    }\n    return 'flex-start';\n  }\n\n  function getAlignItem(node, child) {\n    if (child.style.alignSelf) {\n      return child.style.alignSelf;\n    }\n    if (node.style.alignItems) {\n      return node.style.alignItems;\n    }\n    return 'stretch';\n  }\n\n  function resolveAxis(axis, direction) {\n    if (direction === CSS_DIRECTION_RTL) {\n      if (axis === CSS_FLEX_DIRECTION_ROW) {\n        return CSS_FLEX_DIRECTION_ROW_REVERSE;\n      } else if (axis === CSS_FLEX_DIRECTION_ROW_REVERSE) {\n        return CSS_FLEX_DIRECTION_ROW;\n      }\n    }\n\n    return axis;\n  }\n\n  function resolveDirection(node, parentDirection) {\n    var direction;\n    if (node.style.direction) {\n      direction = node.style.direction;\n    } else {\n      direction = CSS_DIRECTION_INHERIT;\n    }\n\n    if (direction === CSS_DIRECTION_INHERIT) {\n      direction = (parentDirection === undefined ? CSS_DIRECTION_LTR : parentDirection);\n    }\n\n    return direction;\n  }\n\n  function getFlexDirection(node) {\n    if (node.style.flexDirection) {\n      return node.style.flexDirection;\n    }\n    return CSS_FLEX_DIRECTION_COLUMN;\n  }\n\n  function getCrossFlexDirection(flexDirection, direction) {\n    if (isColumnDirection(flexDirection)) {\n      return resolveAxis(CSS_FLEX_DIRECTION_ROW, direction);\n    } else {\n      return CSS_FLEX_DIRECTION_COLUMN;\n    }\n  }\n\n  function getPositionType(node) {\n    if (node.style.position) {\n      return node.style.position;\n    }\n    return 'relative';\n  }\n\n  function isFlex(node) {\n    return (\n      getPositionType(node) === CSS_POSITION_RELATIVE &&\n      node.style.flex > 0\n    );\n  }\n\n  function isFlexWrap(node) {\n    return node.style.flexWrap === 'wrap';\n  }\n\n  function getDimWithMargin(node, axis) {\n    return node.layout[dim[axis]] + getMarginAxis(node, axis);\n  }\n\n  function isDimDefined(node, axis) {\n    return node.style[dim[axis]] !== undefined && node.style[dim[axis]] >= 0;\n  }\n\n  function isPosDefined(node, pos) {\n    return node.style[pos] !== undefined;\n  }\n\n  function isMeasureDefined(node) {\n    return node.style.measure !== undefined;\n  }\n\n  function getPosition(node, pos) {\n    if (node.style[pos] !== undefined) {\n      return node.style[pos];\n    }\n    return 0;\n  }\n\n  function boundAxis(node, axis, value) {\n    var min = {\n      'row': node.style.minWidth,\n      'row-reverse': node.style.minWidth,\n      'column': node.style.minHeight,\n      'column-reverse': node.style.minHeight\n    }[axis];\n\n    var max = {\n      'row': node.style.maxWidth,\n      'row-reverse': node.style.maxWidth,\n      'column': node.style.maxHeight,\n      'column-reverse': node.style.maxHeight\n    }[axis];\n\n    var boundValue = value;\n    if (max !== undefined && max >= 0 && boundValue > max) {\n      boundValue = max;\n    }\n    if (min !== undefined && min >= 0 && boundValue < min) {\n      boundValue = min;\n    }\n    return boundValue;\n  }\n\n  function fmaxf(a, b) {\n    if (a > b) {\n      return a;\n    }\n    return b;\n  }\n\n  // When the user specifically sets a value for width or height\n  function setDimensionFromStyle(node, axis) {\n    // The parent already computed us a width or height. We just skip it\n    if (node.layout[dim[axis]] !== undefined) {\n      return;\n    }\n    // We only run if there's a width or height defined\n    if (!isDimDefined(node, axis)) {\n      return;\n    }\n\n    // The dimensions can never be smaller than the padding and border\n    node.layout[dim[axis]] = fmaxf(\n      boundAxis(node, axis, node.style[dim[axis]]),\n      getPaddingAndBorderAxis(node, axis)\n    );\n  }\n\n  function setTrailingPosition(node, child, axis) {\n    child.layout[trailing[axis]] = node.layout[dim[axis]] -\n        child.layout[dim[axis]] - child.layout[pos[axis]];\n  }\n\n  // If both left and right are defined, then use left. Otherwise return\n  // +left or -right depending on which is defined.\n  function getRelativePosition(node, axis) {\n    if (node.style[leading[axis]] !== undefined) {\n      return getPosition(node, leading[axis]);\n    }\n    return -getPosition(node, trailing[axis]);\n  }\n\n  function layoutNodeImpl(node, parentMaxWidth, /*css_direction_t*/parentDirection) {\n    var/*css_direction_t*/ direction = resolveDirection(node, parentDirection);\n    var/*(c)!css_flex_direction_t*//*(java)!int*/ mainAxis = resolveAxis(getFlexDirection(node), direction);\n    var/*(c)!css_flex_direction_t*//*(java)!int*/ crossAxis = getCrossFlexDirection(mainAxis, direction);\n    var/*(c)!css_flex_direction_t*//*(java)!int*/ resolvedRowAxis = resolveAxis(CSS_FLEX_DIRECTION_ROW, direction);\n\n    // Handle width and height style attributes\n    setDimensionFromStyle(node, mainAxis);\n    setDimensionFromStyle(node, crossAxis);\n\n    // Set the resolved resolution in the node's layout\n    node.layout.direction = direction;\n\n    // The position is set by the parent, but we need to complete it with a\n    // delta composed of the margin and left/top/right/bottom\n    node.layout[leading[mainAxis]] += getLeadingMargin(node, mainAxis) +\n      getRelativePosition(node, mainAxis);\n    node.layout[trailing[mainAxis]] += getTrailingMargin(node, mainAxis) +\n      getRelativePosition(node, mainAxis);\n    node.layout[leading[crossAxis]] += getLeadingMargin(node, crossAxis) +\n      getRelativePosition(node, crossAxis);\n    node.layout[trailing[crossAxis]] += getTrailingMargin(node, crossAxis) +\n      getRelativePosition(node, crossAxis);\n\n    // Inline immutable values from the target node to avoid excessive method\n    // invocations during the layout calculation.\n    var/*int*/ childCount = node.children.length;\n    var/*float*/ paddingAndBorderAxisResolvedRow = getPaddingAndBorderAxis(node, resolvedRowAxis);\n\n    if (isMeasureDefined(node)) {\n      var/*bool*/ isResolvedRowDimDefined = !isUndefined(node.layout[dim[resolvedRowAxis]]);\n\n      var/*float*/ width = CSS_UNDEFINED;\n      if (isDimDefined(node, resolvedRowAxis)) {\n        width = node.style.width;\n      } else if (isResolvedRowDimDefined) {\n        width = node.layout[dim[resolvedRowAxis]];\n      } else {\n        width = parentMaxWidth -\n          getMarginAxis(node, resolvedRowAxis);\n      }\n      width -= paddingAndBorderAxisResolvedRow;\n\n      // We only need to give a dimension for the text if we haven't got any\n      // for it computed yet. It can either be from the style attribute or because\n      // the element is flexible.\n      var/*bool*/ isRowUndefined = !isDimDefined(node, resolvedRowAxis) && !isResolvedRowDimDefined;\n      var/*bool*/ isColumnUndefined = !isDimDefined(node, CSS_FLEX_DIRECTION_COLUMN) &&\n        isUndefined(node.layout[dim[CSS_FLEX_DIRECTION_COLUMN]]);\n\n      // Let's not measure the text if we already know both dimensions\n      if (isRowUndefined || isColumnUndefined) {\n        var/*css_dim_t*/ measureDim = node.style.measure(\n          /*(c)!node->context,*/\n          /*(java)!layoutContext.measureOutput,*/\n          width\n        );\n        if (isRowUndefined) {\n          node.layout.width = measureDim.width +\n            paddingAndBorderAxisResolvedRow;\n        }\n        if (isColumnUndefined) {\n          node.layout.height = measureDim.height +\n            getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_COLUMN);\n        }\n      }\n      if (childCount === 0) {\n        return;\n      }\n    }\n\n    var/*bool*/ isNodeFlexWrap = isFlexWrap(node);\n\n    var/*css_justify_t*/ justifyContent = getJustifyContent(node);\n\n    var/*float*/ leadingPaddingAndBorderMain = getLeadingPaddingAndBorder(node, mainAxis);\n    var/*float*/ leadingPaddingAndBorderCross = getLeadingPaddingAndBorder(node, crossAxis);\n    var/*float*/ paddingAndBorderAxisMain = getPaddingAndBorderAxis(node, mainAxis);\n    var/*float*/ paddingAndBorderAxisCross = getPaddingAndBorderAxis(node, crossAxis);\n\n    var/*bool*/ isMainDimDefined = !isUndefined(node.layout[dim[mainAxis]]);\n    var/*bool*/ isCrossDimDefined = !isUndefined(node.layout[dim[crossAxis]]);\n    var/*bool*/ isMainRowDirection = isRowDirection(mainAxis);\n\n    var/*int*/ i;\n    var/*int*/ ii;\n    var/*css_node_t**/ child;\n    var/*(c)!css_flex_direction_t*//*(java)!int*/ axis;\n\n    var/*css_node_t**/ firstAbsoluteChild = null;\n    var/*css_node_t**/ currentAbsoluteChild = null;\n\n    var/*float*/ definedMainDim = CSS_UNDEFINED;\n    if (isMainDimDefined) {\n      definedMainDim = node.layout[dim[mainAxis]] - paddingAndBorderAxisMain;\n    }\n\n    // We want to execute the next two loops one per line with flex-wrap\n    var/*int*/ startLine = 0;\n    var/*int*/ endLine = 0;\n    // var/*int*/ nextOffset = 0;\n    var/*int*/ alreadyComputedNextLayout = 0;\n    // We aggregate the total dimensions of the container in those two variables\n    var/*float*/ linesCrossDim = 0;\n    var/*float*/ linesMainDim = 0;\n    var/*int*/ linesCount = 0;\n    while (endLine < childCount) {\n      // <Loop A> Layout non flexible children and count children by type\n\n      // mainContentDim is accumulation of the dimensions and margin of all the\n      // non flexible children. This will be used in order to either set the\n      // dimensions of the node if none already exist, or to compute the\n      // remaining space left for the flexible children.\n      var/*float*/ mainContentDim = 0;\n\n      // There are three kind of children, non flexible, flexible and absolute.\n      // We need to know how many there are in order to distribute the space.\n      var/*int*/ flexibleChildrenCount = 0;\n      var/*float*/ totalFlexible = 0;\n      var/*int*/ nonFlexibleChildrenCount = 0;\n\n      // Use the line loop to position children in the main axis for as long\n      // as they are using a simple stacking behaviour. Children that are\n      // immediately stacked in the initial loop will not be touched again\n      // in <Loop C>.\n      var/*bool*/ isSimpleStackMain =\n          (isMainDimDefined && justifyContent === CSS_JUSTIFY_FLEX_START) ||\n          (!isMainDimDefined && justifyContent !== CSS_JUSTIFY_CENTER);\n      var/*int*/ firstComplexMain = (isSimpleStackMain ? childCount : startLine);\n\n      // Use the initial line loop to position children in the cross axis for\n      // as long as they are relatively positioned with alignment STRETCH or\n      // FLEX_START. Children that are immediately stacked in the initial loop\n      // will not be touched again in <Loop D>.\n      var/*bool*/ isSimpleStackCross = true;\n      var/*int*/ firstComplexCross = childCount;\n\n      var/*css_node_t**/ firstFlexChild = null;\n      var/*css_node_t**/ currentFlexChild = null;\n\n      var/*float*/ mainDim = leadingPaddingAndBorderMain;\n      var/*float*/ crossDim = 0;\n\n      var/*float*/ maxWidth;\n      for (i = startLine; i < childCount; ++i) {\n        child = node.children[i];\n        child.lineIndex = linesCount;\n\n        child.nextAbsoluteChild = null;\n        child.nextFlexChild = null;\n\n        var/*css_align_t*/ alignItem = getAlignItem(node, child);\n\n        // Pre-fill cross axis dimensions when the child is using stretch before\n        // we call the recursive layout pass\n        if (alignItem === CSS_ALIGN_STRETCH &&\n            getPositionType(child) === CSS_POSITION_RELATIVE &&\n            isCrossDimDefined &&\n            !isDimDefined(child, crossAxis)) {\n          child.layout[dim[crossAxis]] = fmaxf(\n            boundAxis(child, crossAxis, node.layout[dim[crossAxis]] -\n              paddingAndBorderAxisCross - getMarginAxis(child, crossAxis)),\n            // You never want to go smaller than padding\n            getPaddingAndBorderAxis(child, crossAxis)\n          );\n        } else if (getPositionType(child) === CSS_POSITION_ABSOLUTE) {\n          // Store a private linked list of absolutely positioned children\n          // so that we can efficiently traverse them later.\n          if (firstAbsoluteChild === null) {\n            firstAbsoluteChild = child;\n          }\n          if (currentAbsoluteChild !== null) {\n            currentAbsoluteChild.nextAbsoluteChild = child;\n          }\n          currentAbsoluteChild = child;\n\n          // Pre-fill dimensions when using absolute position and both offsets for the axis are defined (either both\n          // left and right or top and bottom).\n          for (ii = 0; ii < 2; ii++) {\n            axis = (ii !== 0) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;\n            if (!isUndefined(node.layout[dim[axis]]) &&\n                !isDimDefined(child, axis) &&\n                isPosDefined(child, leading[axis]) &&\n                isPosDefined(child, trailing[axis])) {\n              child.layout[dim[axis]] = fmaxf(\n                boundAxis(child, axis, node.layout[dim[axis]] -\n                  getPaddingAndBorderAxis(node, axis) -\n                  getMarginAxis(child, axis) -\n                  getPosition(child, leading[axis]) -\n                  getPosition(child, trailing[axis])),\n                // You never want to go smaller than padding\n                getPaddingAndBorderAxis(child, axis)\n              );\n            }\n          }\n        }\n\n        var/*float*/ nextContentDim = 0;\n\n        // It only makes sense to consider a child flexible if we have a computed\n        // dimension for the node.\n        if (isMainDimDefined && isFlex(child)) {\n          flexibleChildrenCount++;\n          totalFlexible += child.style.flex;\n\n          // Store a private linked list of flexible children so that we can\n          // efficiently traverse them later.\n          if (firstFlexChild === null) {\n            firstFlexChild = child;\n          }\n          if (currentFlexChild !== null) {\n            currentFlexChild.nextFlexChild = child;\n          }\n          currentFlexChild = child;\n\n          // Even if we don't know its exact size yet, we already know the padding,\n          // border and margin. We'll use this partial information, which represents\n          // the smallest possible size for the child, to compute the remaining\n          // available space.\n          nextContentDim = getPaddingAndBorderAxis(child, mainAxis) +\n            getMarginAxis(child, mainAxis);\n\n        } else {\n          maxWidth = CSS_UNDEFINED;\n          if (!isMainRowDirection) {\n            if (isDimDefined(node, resolvedRowAxis)) {\n              maxWidth = node.layout[dim[resolvedRowAxis]] -\n                paddingAndBorderAxisResolvedRow;\n            } else {\n              maxWidth = parentMaxWidth -\n                getMarginAxis(node, resolvedRowAxis) -\n                paddingAndBorderAxisResolvedRow;\n            }\n          }\n\n          // This is the main recursive call. We layout non flexible children.\n          if (alreadyComputedNextLayout === 0) {\n            layoutNode(/*(java)!layoutContext, */child, maxWidth, direction);\n          }\n\n          // Absolute positioned elements do not take part of the layout, so we\n          // don't use them to compute mainContentDim\n          if (getPositionType(child) === CSS_POSITION_RELATIVE) {\n            nonFlexibleChildrenCount++;\n            // At this point we know the final size and margin of the element.\n            nextContentDim = getDimWithMargin(child, mainAxis);\n          }\n        }\n\n        // The element we are about to add would make us go to the next line\n        if (isNodeFlexWrap &&\n            isMainDimDefined &&\n            mainContentDim + nextContentDim > definedMainDim &&\n            // If there's only one element, then it's bigger than the content\n            // and needs its own line\n            i !== startLine) {\n          nonFlexibleChildrenCount--;\n          alreadyComputedNextLayout = 1;\n          break;\n        }\n\n        // Disable simple stacking in the main axis for the current line as\n        // we found a non-trivial child. The remaining children will be laid out\n        // in <Loop C>.\n        if (isSimpleStackMain &&\n            (getPositionType(child) !== CSS_POSITION_RELATIVE || isFlex(child))) {\n          isSimpleStackMain = false;\n          firstComplexMain = i;\n        }\n\n        // Disable simple stacking in the cross axis for the current line as\n        // we found a non-trivial child. The remaining children will be laid out\n        // in <Loop D>.\n        if (isSimpleStackCross &&\n            (getPositionType(child) !== CSS_POSITION_RELATIVE ||\n                (alignItem !== CSS_ALIGN_STRETCH && alignItem !== CSS_ALIGN_FLEX_START) ||\n                isUndefined(child.layout[dim[crossAxis]]))) {\n          isSimpleStackCross = false;\n          firstComplexCross = i;\n        }\n\n        if (isSimpleStackMain) {\n          child.layout[pos[mainAxis]] += mainDim;\n          if (isMainDimDefined) {\n            setTrailingPosition(node, child, mainAxis);\n          }\n\n          mainDim += getDimWithMargin(child, mainAxis);\n          crossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));\n        }\n\n        if (isSimpleStackCross) {\n          child.layout[pos[crossAxis]] += linesCrossDim + leadingPaddingAndBorderCross;\n          if (isCrossDimDefined) {\n            setTrailingPosition(node, child, crossAxis);\n          }\n        }\n\n        alreadyComputedNextLayout = 0;\n        mainContentDim += nextContentDim;\n        endLine = i + 1;\n      }\n\n      // <Loop B> Layout flexible children and allocate empty space\n\n      // In order to position the elements in the main axis, we have two\n      // controls. The space between the beginning and the first element\n      // and the space between each two elements.\n      var/*float*/ leadingMainDim = 0;\n      var/*float*/ betweenMainDim = 0;\n\n      // The remaining available space that needs to be allocated\n      var/*float*/ remainingMainDim = 0;\n      if (isMainDimDefined) {\n        remainingMainDim = definedMainDim - mainContentDim;\n      } else {\n        remainingMainDim = fmaxf(mainContentDim, 0) - mainContentDim;\n      }\n\n      // If there are flexible children in the mix, they are going to fill the\n      // remaining space\n      if (flexibleChildrenCount !== 0) {\n        var/*float*/ flexibleMainDim = remainingMainDim / totalFlexible;\n        var/*float*/ baseMainDim;\n        var/*float*/ boundMainDim;\n\n        // If the flex share of remaining space doesn't meet min/max bounds,\n        // remove this child from flex calculations.\n        currentFlexChild = firstFlexChild;\n        while (currentFlexChild !== null) {\n          baseMainDim = flexibleMainDim * currentFlexChild.style.flex +\n              getPaddingAndBorderAxis(currentFlexChild, mainAxis);\n          boundMainDim = boundAxis(currentFlexChild, mainAxis, baseMainDim);\n\n          if (baseMainDim !== boundMainDim) {\n            remainingMainDim -= boundMainDim;\n            totalFlexible -= currentFlexChild.style.flex;\n          }\n\n          currentFlexChild = currentFlexChild.nextFlexChild;\n        }\n        flexibleMainDim = remainingMainDim / totalFlexible;\n\n        // The non flexible children can overflow the container, in this case\n        // we should just assume that there is no space available.\n        if (flexibleMainDim < 0) {\n          flexibleMainDim = 0;\n        }\n\n        currentFlexChild = firstFlexChild;\n        while (currentFlexChild !== null) {\n          // At this point we know the final size of the element in the main\n          // dimension\n          currentFlexChild.layout[dim[mainAxis]] = boundAxis(currentFlexChild, mainAxis,\n            flexibleMainDim * currentFlexChild.style.flex +\n                getPaddingAndBorderAxis(currentFlexChild, mainAxis)\n          );\n\n          maxWidth = CSS_UNDEFINED;\n          if (isDimDefined(node, resolvedRowAxis)) {\n            maxWidth = node.layout[dim[resolvedRowAxis]] -\n              paddingAndBorderAxisResolvedRow;\n          } else if (!isMainRowDirection) {\n            maxWidth = parentMaxWidth -\n              getMarginAxis(node, resolvedRowAxis) -\n              paddingAndBorderAxisResolvedRow;\n          }\n\n          // And we recursively call the layout algorithm for this child\n          layoutNode(/*(java)!layoutContext, */currentFlexChild, maxWidth, direction);\n\n          child = currentFlexChild;\n          currentFlexChild = currentFlexChild.nextFlexChild;\n          child.nextFlexChild = null;\n        }\n\n      // We use justifyContent to figure out how to allocate the remaining\n      // space available\n      } else if (justifyContent !== CSS_JUSTIFY_FLEX_START) {\n        if (justifyContent === CSS_JUSTIFY_CENTER) {\n          leadingMainDim = remainingMainDim / 2;\n        } else if (justifyContent === CSS_JUSTIFY_FLEX_END) {\n          leadingMainDim = remainingMainDim;\n        } else if (justifyContent === CSS_JUSTIFY_SPACE_BETWEEN) {\n          remainingMainDim = fmaxf(remainingMainDim, 0);\n          if (flexibleChildrenCount + nonFlexibleChildrenCount - 1 !== 0) {\n            betweenMainDim = remainingMainDim /\n              (flexibleChildrenCount + nonFlexibleChildrenCount - 1);\n          } else {\n            betweenMainDim = 0;\n          }\n        } else if (justifyContent === CSS_JUSTIFY_SPACE_AROUND) {\n          // Space on the edges is half of the space between elements\n          betweenMainDim = remainingMainDim /\n            (flexibleChildrenCount + nonFlexibleChildrenCount);\n          leadingMainDim = betweenMainDim / 2;\n        }\n      }\n\n      // <Loop C> Position elements in the main axis and compute dimensions\n\n      // At this point, all the children have their dimensions set. We need to\n      // find their position. In order to do that, we accumulate data in\n      // variables that are also useful to compute the total dimensions of the\n      // container!\n      mainDim += leadingMainDim;\n\n      for (i = firstComplexMain; i < endLine; ++i) {\n        child = node.children[i];\n\n        if (getPositionType(child) === CSS_POSITION_ABSOLUTE &&\n            isPosDefined(child, leading[mainAxis])) {\n          // In case the child is position absolute and has left/top being\n          // defined, we override the position to whatever the user said\n          // (and margin/border).\n          child.layout[pos[mainAxis]] = getPosition(child, leading[mainAxis]) +\n            getLeadingBorder(node, mainAxis) +\n            getLeadingMargin(child, mainAxis);\n        } else {\n          // If the child is position absolute (without top/left) or relative,\n          // we put it at the current accumulated offset.\n          child.layout[pos[mainAxis]] += mainDim;\n\n          // Define the trailing position accordingly.\n          if (isMainDimDefined) {\n            setTrailingPosition(node, child, mainAxis);\n          }\n\n          // Now that we placed the element, we need to update the variables\n          // We only need to do that for relative elements. Absolute elements\n          // do not take part in that phase.\n          if (getPositionType(child) === CSS_POSITION_RELATIVE) {\n            // The main dimension is the sum of all the elements dimension plus\n            // the spacing.\n            mainDim += betweenMainDim + getDimWithMargin(child, mainAxis);\n            // The cross dimension is the max of the elements dimension since there\n            // can only be one element in that cross dimension.\n            crossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));\n          }\n        }\n      }\n\n      var/*float*/ containerCrossAxis = node.layout[dim[crossAxis]];\n      if (!isCrossDimDefined) {\n        containerCrossAxis = fmaxf(\n          // For the cross dim, we add both sides at the end because the value\n          // is aggregate via a max function. Intermediate negative values\n          // can mess this computation otherwise\n          boundAxis(node, crossAxis, crossDim + paddingAndBorderAxisCross),\n          paddingAndBorderAxisCross\n        );\n      }\n\n      // <Loop D> Position elements in the cross axis\n      for (i = firstComplexCross; i < endLine; ++i) {\n        child = node.children[i];\n\n        if (getPositionType(child) === CSS_POSITION_ABSOLUTE &&\n            isPosDefined(child, leading[crossAxis])) {\n          // In case the child is absolutely positionned and has a\n          // top/left/bottom/right being set, we override all the previously\n          // computed positions to set it correctly.\n          child.layout[pos[crossAxis]] = getPosition(child, leading[crossAxis]) +\n            getLeadingBorder(node, crossAxis) +\n            getLeadingMargin(child, crossAxis);\n\n        } else {\n          var/*float*/ leadingCrossDim = leadingPaddingAndBorderCross;\n\n          // For a relative children, we're either using alignItems (parent) or\n          // alignSelf (child) in order to determine the position in the cross axis\n          if (getPositionType(child) === CSS_POSITION_RELATIVE) {\n            /*eslint-disable */\n            // This variable is intentionally re-defined as the code is transpiled to a block scope language\n            var/*css_align_t*/ alignItem = getAlignItem(node, child);\n            /*eslint-enable */\n            if (alignItem === CSS_ALIGN_STRETCH) {\n              // You can only stretch if the dimension has not already been set\n              // previously.\n              if (isUndefined(child.layout[dim[crossAxis]])) {\n                child.layout[dim[crossAxis]] = fmaxf(\n                  boundAxis(child, crossAxis, containerCrossAxis -\n                    paddingAndBorderAxisCross - getMarginAxis(child, crossAxis)),\n                  // You never want to go smaller than padding\n                  getPaddingAndBorderAxis(child, crossAxis)\n                );\n              }\n            } else if (alignItem !== CSS_ALIGN_FLEX_START) {\n              // The remaining space between the parent dimensions+padding and child\n              // dimensions+margin.\n              var/*float*/ remainingCrossDim = containerCrossAxis -\n                paddingAndBorderAxisCross - getDimWithMargin(child, crossAxis);\n\n              if (alignItem === CSS_ALIGN_CENTER) {\n                leadingCrossDim += remainingCrossDim / 2;\n              } else { // CSS_ALIGN_FLEX_END\n                leadingCrossDim += remainingCrossDim;\n              }\n            }\n          }\n\n          // And we apply the position\n          child.layout[pos[crossAxis]] += linesCrossDim + leadingCrossDim;\n\n          // Define the trailing position accordingly.\n          if (isCrossDimDefined) {\n            setTrailingPosition(node, child, crossAxis);\n          }\n        }\n      }\n\n      linesCrossDim += crossDim;\n      linesMainDim = fmaxf(linesMainDim, mainDim);\n      linesCount += 1;\n      startLine = endLine;\n    }\n\n    // <Loop E>\n    //\n    // Note(prenaux): More than one line, we need to layout the crossAxis\n    // according to alignContent.\n    //\n    // Note that we could probably remove <Loop D> and handle the one line case\n    // here too, but for the moment this is safer since it won't interfere with\n    // previously working code.\n    //\n    // See specs:\n    // http://www.w3.org/TR/2012/CR-css3-flexbox-20120918/#layout-algorithm\n    // section 9.4\n    //\n    if (linesCount > 1 && isCrossDimDefined) {\n      var/*float*/ nodeCrossAxisInnerSize = node.layout[dim[crossAxis]] -\n          paddingAndBorderAxisCross;\n      var/*float*/ remainingAlignContentDim = nodeCrossAxisInnerSize - linesCrossDim;\n\n      var/*float*/ crossDimLead = 0;\n      var/*float*/ currentLead = leadingPaddingAndBorderCross;\n\n      var/*css_align_t*/ alignContent = getAlignContent(node);\n      if (alignContent === CSS_ALIGN_FLEX_END) {\n        currentLead += remainingAlignContentDim;\n      } else if (alignContent === CSS_ALIGN_CENTER) {\n        currentLead += remainingAlignContentDim / 2;\n      } else if (alignContent === CSS_ALIGN_STRETCH) {\n        if (nodeCrossAxisInnerSize > linesCrossDim) {\n          crossDimLead = (remainingAlignContentDim / linesCount);\n        }\n      }\n\n      var/*int*/ endIndex = 0;\n      for (i = 0; i < linesCount; ++i) {\n        var/*int*/ startIndex = endIndex;\n\n        // compute the line's height and find the endIndex\n        var/*float*/ lineHeight = 0;\n        for (ii = startIndex; ii < childCount; ++ii) {\n          child = node.children[ii];\n          if (getPositionType(child) !== CSS_POSITION_RELATIVE) {\n            continue;\n          }\n          if (child.lineIndex !== i) {\n            break;\n          }\n          if (!isUndefined(child.layout[dim[crossAxis]])) {\n            lineHeight = fmaxf(\n              lineHeight,\n              child.layout[dim[crossAxis]] + getMarginAxis(child, crossAxis)\n            );\n          }\n        }\n        endIndex = ii;\n        lineHeight += crossDimLead;\n\n        for (ii = startIndex; ii < endIndex; ++ii) {\n          child = node.children[ii];\n          if (getPositionType(child) !== CSS_POSITION_RELATIVE) {\n            continue;\n          }\n\n          var/*css_align_t*/ alignContentAlignItem = getAlignItem(node, child);\n          if (alignContentAlignItem === CSS_ALIGN_FLEX_START) {\n            child.layout[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n          } else if (alignContentAlignItem === CSS_ALIGN_FLEX_END) {\n            child.layout[pos[crossAxis]] = currentLead + lineHeight - getTrailingMargin(child, crossAxis) - child.layout[dim[crossAxis]];\n          } else if (alignContentAlignItem === CSS_ALIGN_CENTER) {\n            var/*float*/ childHeight = child.layout[dim[crossAxis]];\n            child.layout[pos[crossAxis]] = currentLead + (lineHeight - childHeight) / 2;\n          } else if (alignContentAlignItem === CSS_ALIGN_STRETCH) {\n            child.layout[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n            // TODO(prenaux): Correctly set the height of items with undefined\n            //                (auto) crossAxis dimension.\n          }\n        }\n\n        currentLead += lineHeight;\n      }\n    }\n\n    var/*bool*/ needsMainTrailingPos = false;\n    var/*bool*/ needsCrossTrailingPos = false;\n\n    // If the user didn't specify a width or height, and it has not been set\n    // by the container, then we set it via the children.\n    if (!isMainDimDefined) {\n      node.layout[dim[mainAxis]] = fmaxf(\n        // We're missing the last padding at this point to get the final\n        // dimension\n        boundAxis(node, mainAxis, linesMainDim + getTrailingPaddingAndBorder(node, mainAxis)),\n        // We can never assign a width smaller than the padding and borders\n        paddingAndBorderAxisMain\n      );\n\n      if (mainAxis === CSS_FLEX_DIRECTION_ROW_REVERSE ||\n          mainAxis === CSS_FLEX_DIRECTION_COLUMN_REVERSE) {\n        needsMainTrailingPos = true;\n      }\n    }\n\n    if (!isCrossDimDefined) {\n      node.layout[dim[crossAxis]] = fmaxf(\n        // For the cross dim, we add both sides at the end because the value\n        // is aggregate via a max function. Intermediate negative values\n        // can mess this computation otherwise\n        boundAxis(node, crossAxis, linesCrossDim + paddingAndBorderAxisCross),\n        paddingAndBorderAxisCross\n      );\n\n      if (crossAxis === CSS_FLEX_DIRECTION_ROW_REVERSE ||\n          crossAxis === CSS_FLEX_DIRECTION_COLUMN_REVERSE) {\n        needsCrossTrailingPos = true;\n      }\n    }\n\n    // <Loop F> Set trailing position if necessary\n    if (needsMainTrailingPos || needsCrossTrailingPos) {\n      for (i = 0; i < childCount; ++i) {\n        child = node.children[i];\n\n        if (needsMainTrailingPos) {\n          setTrailingPosition(node, child, mainAxis);\n        }\n\n        if (needsCrossTrailingPos) {\n          setTrailingPosition(node, child, crossAxis);\n        }\n      }\n    }\n\n    // <Loop G> Calculate dimensions for absolutely positioned elements\n    currentAbsoluteChild = firstAbsoluteChild;\n    while (currentAbsoluteChild !== null) {\n      // Pre-fill dimensions when using absolute position and both offsets for\n      // the axis are defined (either both left and right or top and bottom).\n      for (ii = 0; ii < 2; ii++) {\n        axis = (ii !== 0) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;\n\n        if (!isUndefined(node.layout[dim[axis]]) &&\n            !isDimDefined(currentAbsoluteChild, axis) &&\n            isPosDefined(currentAbsoluteChild, leading[axis]) &&\n            isPosDefined(currentAbsoluteChild, trailing[axis])) {\n          currentAbsoluteChild.layout[dim[axis]] = fmaxf(\n            boundAxis(currentAbsoluteChild, axis, node.layout[dim[axis]] -\n              getBorderAxis(node, axis) -\n              getMarginAxis(currentAbsoluteChild, axis) -\n              getPosition(currentAbsoluteChild, leading[axis]) -\n              getPosition(currentAbsoluteChild, trailing[axis])\n            ),\n            // You never want to go smaller than padding\n            getPaddingAndBorderAxis(currentAbsoluteChild, axis)\n          );\n        }\n\n        if (isPosDefined(currentAbsoluteChild, trailing[axis]) &&\n            !isPosDefined(currentAbsoluteChild, leading[axis])) {\n          currentAbsoluteChild.layout[leading[axis]] =\n            node.layout[dim[axis]] -\n            currentAbsoluteChild.layout[dim[axis]] -\n            getPosition(currentAbsoluteChild, trailing[axis]);\n        }\n      }\n\n      child = currentAbsoluteChild;\n      currentAbsoluteChild = currentAbsoluteChild.nextAbsoluteChild;\n      child.nextAbsoluteChild = null;\n    }\n  }\n\n  function layoutNode(node, parentMaxWidth, parentDirection) {\n    node.shouldUpdate = true;\n\n    var direction = node.style.direction || CSS_DIRECTION_LTR;\n    var skipLayout =\n      !node.isDirty &&\n      node.lastLayout &&\n      node.lastLayout.requestedHeight === node.layout.height &&\n      node.lastLayout.requestedWidth === node.layout.width &&\n      node.lastLayout.parentMaxWidth === parentMaxWidth &&\n      node.lastLayout.direction === direction;\n\n    if (skipLayout) {\n      node.layout.width = node.lastLayout.width;\n      node.layout.height = node.lastLayout.height;\n      node.layout.top = node.lastLayout.top;\n      node.layout.left = node.lastLayout.left;\n    } else {\n      if (!node.lastLayout) {\n        node.lastLayout = {};\n      }\n\n      node.lastLayout.requestedWidth = node.layout.width;\n      node.lastLayout.requestedHeight = node.layout.height;\n      node.lastLayout.parentMaxWidth = parentMaxWidth;\n      node.lastLayout.direction = direction;\n\n      // Reset child layouts\n      node.children.forEach(function(child) {\n        child.layout.width = undefined;\n        child.layout.height = undefined;\n        child.layout.top = 0;\n        child.layout.left = 0;\n      });\n\n      layoutNodeImpl(node, parentMaxWidth, parentDirection);\n\n      node.lastLayout.width = node.layout.width;\n      node.lastLayout.height = node.layout.height;\n      node.lastLayout.top = node.layout.top;\n      node.lastLayout.left = node.layout.left;\n    }\n  }\n\n  return {\n    layoutNodeImpl: layoutNodeImpl,\n    computeLayout: layoutNode,\n    fillNodes: fillNodes\n  };\n})();\n\n// This module export is only used for the purposes of unit testing this file. When\n// the library is packaged this file is included within css-layout.js which forms\n// the public API.\nif (typeof exports === 'object') {\n  module.exports = computeLayout;\n}\n","/home/travis/build/npmtest/node-npmtest-css-layout/node_modules/css-layout/src/transpile.js":"/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\nvar layoutTestUtils = require('./Layout-test-utils.js');\nvar computeLayout = require('./Layout.js').layoutNodeImpl;\nvar fs = require('fs');\nvar JavaTranspiler = require('./JavaTranspiler.js');\nvar CSharpTranspiler = require('./CSharpTranspiler.js');\n\nvar currentTest = '';\nvar allTests = [];\nvar computeDOMLayout = layoutTestUtils.computeDOMLayout;\nvar reduceTest = layoutTestUtils.reduceTest;\nglobal.layoutTestUtils = {\n  testLayout: function(node, expectedLayout) {\n    allTests.push({name: currentTest, node: node, expectedLayout: expectedLayout});\n  },\n  testLayoutAgainstDomOnly: function() {\n  },\n  testRandomLayout: function(node, i) {\n    allTests.push({name: 'Random #' + i, node: node, expectedLayout: computeDOMLayout(node)});\n  },\n  computeLayout: layoutTestUtils.computeLayout,\n  reduceTest: reduceTest,\n  text: layoutTestUtils.text,\n  texts: layoutTestUtils.texts,\n  textSizes: layoutTestUtils.textSizes\n};\n\nglobal.describe = function(name, cb) {\n  if (name === 'Layout' ||\n      name === 'Layout alignContent') {\n    cb();\n  }\n};\nglobal.it = function(name, cb) { currentTest = name; cb(); };\nglobal.xit = function() { /* ignore skipped tests */ };\n\nrequire('./__tests__/Layout-test.js');\n\n\nfunction printLayout(test) {\n  var level = 1;\n  var res = [];\n\n  function indent(level) {\n    var result = '';\n    for (var i = 0; i < level; ++i) {\n      result += '  ';\n    }\n    return result;\n  }\n\n  function add(str) {\n    if (str.length > 0) {\n      str = indent(level) + str;\n    }\n    res.push(str);\n  }\n\n  function isEmpty(obj) {\n    return !Object.keys(obj).length;\n  }\n\n  add('{');\n  level++;\n\n  // Output the style node\n  add('css_node_t *root_node = new_test_css_node();');\n  add('{');\n  level++;\n  if (!isEmpty(test.node.style) || test.node.children && test.node.children.length) {\n    add('css_node_t *node_0 = root_node;');\n  }\n  function recStyle(node) {\n\n    function addStyle(str) {\n      add('node_' + (level - 3) + '->style.' + str);\n    }\n\n    function addEnum(node, jsKey, cKey, dict) {\n      if (jsKey in node.style) {\n        addStyle(cKey + ' = ' + dict[node.style[jsKey]] + ';');\n      }\n    }\n\n    function addFloat(node, jsKey, cKey) {\n      if (jsKey in node.style) {\n        addStyle(cKey + ' = ' + node.style[jsKey] + ';');\n      }\n    }\n\n    function addSpacing(node, spacing, suffix) {\n      addFloat(node, spacing + suffix, spacing + '[CSS_LEFT]');\n      addFloat(node, spacing + suffix, spacing + '[CSS_TOP]');\n      addFloat(node, spacing + suffix, spacing + '[CSS_RIGHT]');\n      addFloat(node, spacing + suffix, spacing + '[CSS_BOTTOM]');\n      addFloat(node, spacing + suffix, spacing + '[CSS_START]');\n      addFloat(node, spacing + suffix, spacing + '[CSS_END]');\n\n      addFloat(node, spacing + 'Left' + suffix, spacing + '[CSS_LEFT]');\n      addFloat(node, spacing + 'Top' + suffix, spacing + '[CSS_TOP]');\n      addFloat(node, spacing + 'Right' + suffix, spacing + '[CSS_RIGHT]');\n      addFloat(node, spacing + 'Bottom' + suffix, spacing + '[CSS_BOTTOM]');\n      addFloat(node, spacing + 'Start' + suffix, spacing + '[CSS_START]');\n      addFloat(node, spacing + 'End' + suffix, spacing + '[CSS_END]');\n    }\n\n    function addMeasure(node) {\n      if ('measure' in node.style) {\n        add('node_' + (level - 3) + '->measure = measure;');\n        add('node_' + (level - 3) + '->context = \"' + node.style.measure.toString() + '\";');\n      }\n    }\n\n    addEnum(node, 'direction', 'direction', {\n      'ltr': 'CSS_DIRECTION_LTR',\n      'rtl': 'CSS_DIRECTION_RTL'\n    });\n    addEnum(node, 'flexDirection', 'flex_direction', {\n      'row': 'CSS_FLEX_DIRECTION_ROW',\n      'row-reverse': 'CSS_FLEX_DIRECTION_ROW_REVERSE',\n      'column': 'CSS_FLEX_DIRECTION_COLUMN',\n      'column-reverse': 'CSS_FLEX_DIRECTION_COLUMN_REVERSE'\n    });\n    addEnum(node, 'justifyContent', 'justify_content', {\n      'flex-start': 'CSS_JUSTIFY_FLEX_START',\n      'center': 'CSS_JUSTIFY_CENTER',\n      'flex-end': 'CSS_JUSTIFY_FLEX_END',\n      'space-between': 'CSS_JUSTIFY_SPACE_BETWEEN',\n      'space-around': 'CSS_JUSTIFY_SPACE_AROUND'\n    });\n    addEnum(node, 'alignContent', 'align_content', {\n      'flex-start': 'CSS_ALIGN_FLEX_START',\n      'center': 'CSS_ALIGN_CENTER',\n      'flex-end': 'CSS_ALIGN_FLEX_END',\n      'stretch': 'CSS_ALIGN_STRETCH'\n    });\n    addEnum(node, 'alignItems', 'align_items', {\n      'flex-start': 'CSS_ALIGN_FLEX_START',\n      'center': 'CSS_ALIGN_CENTER',\n      'flex-end': 'CSS_ALIGN_FLEX_END',\n      'stretch': 'CSS_ALIGN_STRETCH'\n    });\n    addEnum(node, 'alignSelf', 'align_self', {\n      'flex-start': 'CSS_ALIGN_FLEX_START',\n      'center': 'CSS_ALIGN_CENTER',\n      'flex-end': 'CSS_ALIGN_FLEX_END',\n      'stretch': 'CSS_ALIGN_STRETCH'\n    });\n    addEnum(node, 'position', 'position_type', {\n      'relative': 'CSS_POSITION_RELATIVE',\n      'absolute': 'CSS_POSITION_ABSOLUTE'\n    });\n    addEnum(node, 'flexWrap', 'flex_wrap', {\n      'nowrap': 'CSS_NOWRAP',\n      'wrap': 'CSS_WRAP'\n    });\n    addFloat(node, 'flex', 'flex');\n    addFloat(node, 'width', 'dimensions[CSS_WIDTH]');\n    addFloat(node, 'height', 'dimensions[CSS_HEIGHT]');\n    addFloat(node, 'maxWidth', 'maxDimensions[CSS_WIDTH]');\n    addFloat(node, 'maxHeight', 'maxDimensions[CSS_HEIGHT]');\n    addFloat(node, 'minWidth', 'minDimensions[CSS_WIDTH]');\n    addFloat(node, 'minHeight', 'minDimensions[CSS_HEIGHT]');\n    addSpacing(node, 'margin', '');\n    addSpacing(node, 'padding', '');\n    addSpacing(node, 'border', 'Width');\n    addFloat(node, 'left', 'position[CSS_LEFT]');\n    addFloat(node, 'top', 'position[CSS_TOP]');\n    addFloat(node, 'right', 'position[CSS_RIGHT]');\n    addFloat(node, 'bottom', 'position[CSS_BOTTOM]');\n    addMeasure(node);\n\n    if (node.children) {\n      add('init_css_node_children(node_' + (level - 3) + ', ' + node.children.length + ');');\n      add('{');\n      level++;\n      add('css_node_t *node_' + (level - 3) + ';');\n\n      for (var i = 0; i < node.children.length; ++i) {\n        add('node_' + (level - 3) + ' = node_' + (level - 4) + '->get_child(node_' + (level - 4) + '->context, ' + i + ');');\n        recStyle(node.children[i]);\n      }\n\n      level--;\n      add('}');\n    }\n  }\n  recStyle(test.node);\n  level--;\n  add('}');\n  add('');\n\n  // Output the expected layout node\n  add('css_node_t *root_layout = new_test_css_node();');\n  add('{');\n  level++;\n  add('css_node_t *node_0 = root_layout;');\n\n  function recLayout(node) {\n    function addLayout(str) {\n      add('node_' + (level - 3) + '->layout.' + str);\n    }\n\n    addLayout('position[CSS_TOP] = ' + node.top + ';');\n    addLayout('position[CSS_LEFT] = ' + node.left + ';');\n    addLayout('dimensions[CSS_WIDTH] = ' + node.width + ';');\n    addLayout('dimensions[CSS_HEIGHT] = ' + node.height + ';');\n\n    if (node.children) {\n      add('init_css_node_children(node_' + (level - 3) + ', ' + node.children.length + ');');\n      add('{');\n      level++;\n      add('css_node_t *node_' + (level - 3) + ';');\n\n      for (var i = 0; i < node.children.length; ++i) {\n        add('node_' + (level - 3) + ' = node_' + (level - 4) + '->get_child(node_' + (level - 4) + '->context, ' + i + ');');\n        recLayout(node.children[i]);\n      }\n\n      level--;\n      add('}');\n    }\n  }\n  recLayout(test.expectedLayout);\n  level--;\n  add('}');\n  add('');\n\n  // Do the test\n  add('test(\"' + test.name.replace(/\"/g, '\\\\\"') + '\", root_node, root_layout);');\n  level--;\n  add('}');\n  return res.join('\\n');\n}\n\nfunction transpileAnnotatedJStoC(jsCode) {\n  return jsCode\n    .replace('node.style.measure', 'node.measure')\n    .replace(/null/g, 'NULL')\n    .replace(/\\.children\\.length/g, '.children_count')\n    .replace(/\\.width/g, '.dimensions[CSS_WIDTH]')\n    .replace(/\\.height/g, '.dimensions[CSS_HEIGHT]')\n    .replace(/\\.maxWidth/g, '.maxDimensions[CSS_WIDTH]')\n    .replace(/\\.maxHeight/g, '.maxDimensions[CSS_HEIGHT]')\n    .replace(/\\.minWidth/g, '.minDimensions[CSS_WIDTH]')\n    .replace(/\\.minHeight/g, '.minDimensions[CSS_HEIGHT]')\n    .replace(/\\.lineIndex/g, '.line_index')\n    .replace(/\\.nextAbsoluteChild/g, '.next_absolute_child')\n    .replace(/\\.nextFlexChild/g, '.next_flex_child')\n    .replace(/layout\\[dim/g, 'layout.dimensions[dim')\n    .replace(/layout\\[pos/g, 'layout.position[pos')\n    .replace(/layout\\[leading/g, 'layout.position[leading')\n    .replace(/layout\\[trailing/g, 'layout.position[trailing')\n    .replace(/style\\[dim/g, 'style.dimensions[dim')\n    .replace(/node.children\\[i\\]/g, 'node->get_child(node->context, i)')\n    .replace(/node.children\\[ii\\]/g, 'node->get_child(node->context, ii)')\n    .replace(/node\\./g, 'node->')\n    .replace(/child\\./g, 'child->')\n    .replace(/parent\\./g, 'parent->')\n    .replace(/currentAbsoluteChild\\./g, 'currentAbsoluteChild->')\n    .replace(/currentFlexChild\\./g, 'currentFlexChild->')\n    .replace(/getPositionType\\((.+?)\\)/g, '$1->style.position_type')\n    .replace(/getJustifyContent\\((.+?)\\)/g, '$1->style.justify_content')\n    .replace(/getAlignContent\\((.+?)\\)/g, '$1->style.align_content')\n    .replace(/var\\/\\*\\(c\\)!([^*]+)\\*\\//g, '$1')\n    .replace(/var\\/\\*([^\\/]+)\\*\\//g, '$1')\n    .replace(/ === /g, ' == ')\n    .replace(/ !== /g, ' != ')\n    .replace(/\\n {2}/g, '\\n')\n    .replace(/\\/\\*\\(c\\)!([^*]+)\\*\\//g, '$1')\n    .replace(/\\/[*]!([^*]+)[*]\\//g, '$1')\n    .replace(/\\/\\*\\(java\\)!([^*]+)\\*\\//g, '')\n    .split('\\n').slice(1, -1).join('\\n');\n}\n\nfunction makeConstDefs() {\n  var lines = [\n    '#define SMALL_WIDTH ' + layoutTestUtils.textSizes.smallWidth,\n    '#define SMALL_HEIGHT ' + layoutTestUtils.textSizes.smallHeight,\n    '#define BIG_WIDTH ' + layoutTestUtils.textSizes.bigWidth,\n    '#define BIG_HEIGHT ' + layoutTestUtils.textSizes.bigHeight,\n    '#define BIG_MIN_WIDTH ' + layoutTestUtils.textSizes.bigMinWidth,\n    '#define SMALL_TEXT \"' + layoutTestUtils.texts.small + '\"',\n    '#define LONG_TEXT \"' + layoutTestUtils.texts.big + '\"'\n  ];\n  return lines.join('\\n');\n}\n\nfunction generateFile(fileName, generatedContent) {\n  var content = fs.readFileSync(fileName, 'utf8').toString();\n  content = content.replace(new RegExp(\n    /\\/\\*\\* START_GENERATED \\*\\*\\/[\\s\\S]*\\/\\*\\* END_GENERATED \\*\\*\\//\n  ), '/** START_GENERATED **/\\n' + generatedContent + '\\n  /** END_GENERATED **/');\n\n  fs.writeFileSync(fileName, content);\n}\n\n\nvar allTestsInC = allTests.map(printLayout);\ngenerateFile(__dirname + '/__tests__/Layout-test.c', allTestsInC.join('\\n\\n'));\ngenerateFile(__dirname + '/Layout-test-utils.c', makeConstDefs());\ngenerateFile(__dirname + '/Layout.c', transpileAnnotatedJStoC(computeLayout.toString()));\ngenerateFile(__dirname + '/java/src/com/facebook/csslayout/LayoutEngine.java', JavaTranspiler.transpileLayoutEngine(computeLayout.toString()));\ngenerateFile(__dirname + '/java/tests/com/facebook/csslayout/TestConstants.java', JavaTranspiler.transpileCConstDefs(makeConstDefs()));\ngenerateFile(__dirname + '/java/tests/com/facebook/csslayout/LayoutEngineTest.java', JavaTranspiler.transpileCTestsArray(allTestsInC));\ngenerateFile(__dirname + '/csharp/Facebook.CSSLayout/LayoutEngine.cs', CSharpTranspiler.transpileLayoutEngine(computeLayout.toString()));\ngenerateFile(__dirname + '/csharp/Facebook.CSSLayout.Tests/TestConstants.cs', CSharpTranspiler.transpileCConstDefs(makeConstDefs()));\ngenerateFile(__dirname + '/csharp/Facebook.CSSLayout.Tests/LayoutEngineTest.cs', CSharpTranspiler.transpileCTestsArray(allTestsInC));\n","/home/travis/build/npmtest/node-npmtest-css-layout/node_modules/css-layout/src/Layout-test-utils.js":"/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n/* globals document, computeLayout, navigator */\n\nvar layoutTestUtils = (function() {\n\n  //\n  // Sets the test cases precision, by default set to 1.0, aka pixel precision\n  // (assuming the browser does pixel snapping - and that we're ok with being\n  // 'only' pixel perfect).\n  //\n  // Set it to '10' for .1 precision, etc... in theory the browser is doing\n  // 'pixel' snapping so 1.0 should do, the code is left for clarity...\n  //\n  // Set it to undefined to disable and use full precision.\n  //\n  var testMeasurePrecision = 1.0;\n\n  if (typeof jasmine !== 'undefined') {\n    jasmine.matchersUtil.buildFailureMessage = function() {\n      var args = Array.prototype.slice.call(arguments, 0);\n      var matcherName = args[0];\n      var isNot = args[1];\n      var actual = args[2];\n      var expected = args.slice(3);\n      var englishyPredicate = matcherName.replace(/[A-Z]/g, function(s) { return ' ' + s.toLowerCase(); });\n\n      var pp = function(node) {\n        return jasmine.pp(node)\n          .replace(/([\\{\\[]) /g, '$1')\n          .replace(/ ([\\}\\]:])/g, '$1');\n      };\n\n      var message = 'Expected ' +\n        pp(actual) +\n        (isNot ? ' not ' : ' ') +\n        '\\n' +\n        englishyPredicate;\n\n      if (expected.length > 0) {\n        for (var i = 0; i < expected.length; i++) {\n          if (i > 0) {\n            message += ',';\n          }\n          message += ' ' + pp(expected[i]);\n        }\n      }\n\n      return message + '.';\n    };\n  }\n\n  var _cachedIframe;\n\n  function renderIframe() {\n    var iframe = document.createElement('iframe');\n    document.body.appendChild(iframe);\n    return iframe;\n  }\n\n  function getIframe(iframe) {\n    if (_cachedIframe) {\n      return _cachedIframe;\n    }\n\n    var doc = iframe.contentDocument;\n\n    if (doc.readyState === 'complete') {\n      var style = document.createElement('style');\n      style.textContent = (function() {/*\n        body, div {\n          box-sizing: border-box;\n          border: 0 solid black;\n          position: relative;\n\n          display: flex;\n          display: -webkit-flex;\n          flex-direction: column;\n          -webkit-flex-direction: column;\n          align-items: stretch;\n          -webkit-align-items: stretch;\n          justify-content: flex-start;\n          -webkit-justify-content: flex-start;\n          flex-shrink: 0;\n          -webkit-flex-shrink: 0;\n\n          margin: 0;\n          padding: 0;\n        }\n\n        hack to ignore three hundred px width of the body {}\n        body > div {\n          align-self: flex-start;\n        }\n      */} + '').slice(15, -4);\n      doc.head.appendChild(style);\n      _cachedIframe = iframe;\n      return iframe;\n    } else {\n      setTimeout(getIframe.bind(null, iframe), 0);\n    }\n  }\n\n  if (typeof window !== 'undefined') {\n    var iframe = renderIframe();\n    getIframe(iframe);\n  }\n\n  if (typeof computeLayout === 'object') {\n    var fillNodes = computeLayout.fillNodes;\n    var realComputeLayout = computeLayout.computeLayout;\n  }\n\n  function extractNodes(node) {\n    var layout = node.layout;\n    delete node.layout;\n    if (node.children && node.children.length > 0) {\n      layout.children = node.children.map(extractNodes);\n    } else {\n      delete node.children;\n    }\n\n    delete layout.right;\n    delete layout.bottom;\n    delete layout.direction;\n\n    return layout;\n  }\n\n  function roundLayout(layout) {\n    // Chrome rounds all the numbers with a precision of 1/64\n    // Reproduce the same behavior\n    function round(number) {\n      var floored = Math.floor(number);\n      var decimal = number - floored;\n      if (decimal === 0) {\n        return number;\n      }\n      var minDifference = Infinity;\n      var minDecimal = Infinity;\n      for (var i = 1; i < 64; ++i) {\n        var roundedDecimal = i / 64;\n        var difference = Math.abs(roundedDecimal - decimal);\n        if (difference < minDifference) {\n          minDifference = difference;\n          minDecimal = roundedDecimal;\n        }\n      }\n      return floored + minDecimal;\n    }\n\n    function rec(layout) {\n      layout.top = round(layout.top);\n      layout.left = round(layout.left);\n      layout.width = round(layout.width);\n      layout.height = round(layout.height);\n      if (layout.children) {\n        for (var i = 0; i < layout.children.length; ++i) {\n          rec(layout.children[i]);\n        }\n      }\n    }\n\n    rec(layout);\n    return layout;\n  }\n\n  function capitalizeFirst(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  }\n\n  function computeCSSLayout(rootNode) {\n    fillNodes(rootNode);\n    realComputeLayout(rootNode);\n    return roundLayout(extractNodes(rootNode));\n  }\n\n  function computeDOMLayout(node) {\n    var body = getIframe().contentDocument.body;\n\n    function transfer(div, node, name, ext) {\n      if (name in node.style) {\n        var value = node.style[name] + (ext || '');\n        div.style['-webkit-' + name] = value;\n        div.style['webkit' + capitalizeFirst(name)] = value;\n        div.style[name] = value;\n      }\n    }\n\n    function transferSpacing(div, node, type, suffix) {\n      transfer(div, node, type + suffix, 'px');\n      transfer(div, node, type + 'Left' + suffix, 'px');\n      transfer(div, node, type + 'Top' + suffix, 'px');\n      transfer(div, node, type + 'Bottom' + suffix, 'px');\n      transfer(div, node, type + 'Right' + suffix, 'px');\n      transfer(div, node, type + 'Start' + suffix, 'px');\n      transfer(div, node, type + 'End' + suffix, 'px');\n    }\n\n    function renderNode(parent, node) {\n      var div = document.createElement('div');\n      transfer(div, node, 'width', 'px');\n      transfer(div, node, 'height', 'px');\n      transfer(div, node, 'minWidth', 'px');\n      transfer(div, node, 'minHeight', 'px');\n      transfer(div, node, 'maxWidth', 'px');\n      transfer(div, node, 'maxHeight', 'px');\n      transfer(div, node, 'top', 'px');\n      transfer(div, node, 'left', 'px');\n      transfer(div, node, 'right', 'px');\n      transfer(div, node, 'bottom', 'px');\n      transferSpacing(div, node, 'margin', '');\n      transferSpacing(div, node, 'padding', '');\n      transferSpacing(div, node, 'border', 'Width');\n      transfer(div, node, 'flexDirection');\n      transfer(div, node, 'direction');\n      transfer(div, node, 'flex');\n      transfer(div, node, 'flexWrap');\n      transfer(div, node, 'justifyContent');\n      transfer(div, node, 'alignSelf');\n      transfer(div, node, 'alignItems');\n      transfer(div, node, 'alignContent');\n      transfer(div, node, 'position');\n      parent.appendChild(div);\n      (node.children || []).forEach(function(child) {\n        renderNode(div, child);\n      });\n      if (node.style.measure) {\n        div.innerText = node.style.measure.toString();\n      }\n      return div;\n    }\n\n    var div = renderNode(body, node);\n\n    function buildLayout(absoluteRect, div) {\n      var rect = div.getBoundingClientRect();\n      var result = {\n        width: rect.width,\n        height: rect.height,\n        top: rect.top - absoluteRect.top,\n        left: rect.left - absoluteRect.left\n      };\n\n      var children = [];\n      for (var child = div.firstChild; child; child = child.nextSibling) {\n        if (child.nodeType !== 3 /* textNode */) {\n          children.push(buildLayout(rect, child));\n        }\n      }\n      if (children.length) {\n        result.children = children;\n      }\n      return result;\n    }\n    var layout = buildLayout({left: 0, top: 0}, div);\n    body.removeChild(div);\n    return layout;\n  }\n\n  function inplaceRoundNumbersInObject(obj) {\n    if (!testMeasurePrecision) {\n      // undefined/0, disables rounding\n      return;\n    }\n\n    for (var key in obj) {\n      if (!obj.hasOwnProperty(key)) {\n        continue;\n      }\n\n      var val = obj[key];\n      if (typeof val === 'number') {\n        obj[key] = Math.floor((val * testMeasurePrecision) + 0.5) / testMeasurePrecision;\n      } else if (typeof val === 'object') {\n        inplaceRoundNumbersInObject(val);\n      }\n    }\n  }\n\n  function nameLayout(name, layout) {\n    var namedLayout = {name: name};\n    for (var key in layout) {\n      namedLayout[key] = layout[key];\n    }\n    return namedLayout;\n  }\n\n  function testFillNodes(node, filledNode) {\n    expect(fillNodes(node)).toEqual(filledNode);\n  }\n\n  function testExtractNodes(node, extractedNode) {\n    expect(extractNodes(node)).toEqual(extractedNode);\n  }\n\n  function testNamedLayout(name, layoutA, layoutB) {\n    expect(nameLayout(name, layoutA))\n      .toEqual(nameLayout(name, layoutB));\n  }\n\n  function isEqual(a, b) {\n    // computeCSSLayout and computeDOMLayout output a tree with same ordered elements\n    return JSON.stringify(a) === JSON.stringify(b);\n  }\n\n  function reduceTest(node) {\n    function isWorking() {\n      return isEqual(\n        computeDOMLayout(node),\n        computeCSSLayout(node)\n      );\n    }\n    if (isWorking()) {\n      return node;\n    }\n\n    var isModified = true;\n\n    function rec(node) {\n      var key;\n      var value;\n\n      // Style\n      for (key in node.style) {\n        value = node.style[key];\n        delete node.style[key];\n        if (isWorking()) {\n          node.style[key] = value;\n        } else {\n          isModified = true;\n        }\n      }\n      // Round values\n      for (key in node.style) {\n        value = node.style[key];\n        if (value > 100) {\n          node.style[key] = Math.round(value / 100) * 100;\n        } else if (value > 10) {\n          node.style[key] = Math.round(value / 10) * 10;\n        } else if (value > 1) {\n          node.style[key] = 5;\n        }\n        if (node.style[key] !== value) {\n          if (isWorking()) {\n            node.style[key] = value;\n          } else {\n            isModified = true;\n          }\n        }\n      }\n      // Children\n      for (var i = 0; node.children && i < node.children.length; ++i) {\n        value = node.children[i];\n        node.children.splice(i, 1);\n        if (isWorking()) {\n          if (!node.children) {\n            node.children = [];\n          }\n          node.children.splice(i, 0, value);\n          rec(node.children[i]);\n        } else {\n          i--;\n          isModified = true;\n        }\n      }\n    }\n    while (isModified) {\n      isModified = false;\n      rec(node);\n    }\n\n    return node;\n  }\n\n  var iframeText;\n  function measureTextSizes(text, width) {\n    iframeText = iframeText || document.createElement('iframe');\n    document.body.appendChild(iframeText);\n\n    var body = iframeText.contentDocument.body;\n    if (width === undefined || isNaN(width)) {\n      width = Infinity;\n    }\n\n    var div = document.createElement('div');\n    div.style.width = (width === Infinity ? 10000000 : width) + 'px';\n    div.style.display = 'flex';\n    div.style.flexDirection = 'column';\n    div.style.alignItems = 'flex-start';\n    div.style.alignContent = 'flex-start';\n\n    var span = document.createElement('span');\n    span.style.display = 'flex';\n    span.style.flexDirection = 'column';\n    span.style.alignItems = 'flex-start';\n    span.style.alignContent = 'flex-start';\n    span.innerText = text;\n\n    div.appendChild(span);\n    body.appendChild(div);\n    var rect = span.getBoundingClientRect();\n    body.removeChild(div);\n    return {\n      width: rect.width,\n      height: rect.height\n    };\n  }\n\n  var texts = {\n    small: 'small',\n    big: 'loooooooooong with space'\n  };\n\n  var preDefinedTextSizes = {\n    smallWidth: 34.671875,\n    smallHeight: 18,\n    bigWidth: 172.421875,\n    bigHeight: 36,\n    bigMinWidth: 100.4375\n  };\n\n  // Note(prenaux): Clearly not what I would like, but it seems to be the only\n  //                way :( My guess is that since the font on Windows is\n  //                different than on OSX it has a different size.\n  if (typeof navigator !== 'undefined' && navigator.userAgent.indexOf('Windows NT') > -1) {\n    preDefinedTextSizes.bigHeight = 36;\n  }\n\n  var textSizes;\n  if (typeof require === 'function') {\n    textSizes = preDefinedTextSizes;\n  } else {\n    textSizes = {\n      smallWidth: measureTextSizes(texts.small, 0).width,\n      smallHeight: measureTextSizes(texts.small, 0).height,\n      bigWidth: measureTextSizes(texts.big).width,\n      bigHeight: measureTextSizes(texts.big, 0).height,\n      bigMinWidth: measureTextSizes(texts.big, 0).width\n    };\n  }\n\n  // round the text sizes so that we dont have to update it for every browser\n  // update, assumes we're ok with pixel precision\n  inplaceRoundNumbersInObject(preDefinedTextSizes);\n  inplaceRoundNumbersInObject(textSizes);\n\n  return {\n    texts: texts,\n    textSizes: textSizes,\n    preDefinedTextSizes: preDefinedTextSizes,\n    testLayout: function(node, expectedLayout) {\n      var layout = computeCSSLayout(node);\n      var domLayout = computeDOMLayout(node);\n      inplaceRoundNumbersInObject(layout);\n      inplaceRoundNumbersInObject(domLayout);\n      inplaceRoundNumbersInObject(expectedLayout);\n      testNamedLayout('expected-dom', expectedLayout, domLayout);\n      testNamedLayout('layout-dom', layout, domLayout);\n    },\n    testLayoutAgainstDomOnly: function(node) {\n      var layout = computeCSSLayout(node);\n      var domLayout = computeDOMLayout(node);\n      inplaceRoundNumbersInObject(layout);\n      inplaceRoundNumbersInObject(domLayout);\n      testNamedLayout('layout-dom', layout, domLayout);\n    },\n    testFillNodes: testFillNodes,\n    testExtractNodes: testExtractNodes,\n    testRandomLayout: function(node) {\n      var layout = computeCSSLayout(node);\n      var domLayout = computeDOMLayout(node);\n      inplaceRoundNumbersInObject(layout);\n      inplaceRoundNumbersInObject(domLayout);\n      expect({node: node, layout: layout})\n        .toEqual({node: node, layout: domLayout});\n    },\n    testsFinished: function() {\n      console.log('tests finished!');\n    },\n    computeLayout: computeCSSLayout,\n    computeDOMLayout: computeDOMLayout,\n    reduceTest: reduceTest,\n    text: function(text) {\n      var fn = function(width) {\n        if (width === undefined || isNaN(width)) {\n          width = Infinity;\n        }\n\n        // Constants for testing purposes between C/JS and other platforms\n        // Comment this block of code if you want to use the browser to\n        // generate proper sizes\n        if (text === texts.small) {\n          return {\n            width: Math.min(textSizes.smallWidth, width),\n            height: textSizes.smallHeight\n          };\n        }\n        if (text === texts.big) {\n          var res = {\n            width: width >= textSizes.bigWidth ? textSizes.bigWidth : Math.max(textSizes.bigMinWidth, width),\n            height: width >= textSizes.bigWidth ? textSizes.smallHeight : textSizes.bigHeight\n          };\n          return res;\n        }\n      };\n      fn.toString = function() { return text; };\n      return fn;\n    }\n  };\n})();\n\nif (typeof module !== 'undefined') {\n  module.exports = layoutTestUtils;\n}\n","/home/travis/build/npmtest/node-npmtest-css-layout/node_modules/css-layout/src/__tests__/Layout-test.js":"/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n/* globals layoutTestUtils */\n\nvar testLayout = layoutTestUtils.testLayout;\nvar testLayoutAgainstDomOnly = layoutTestUtils.testLayoutAgainstDomOnly;\nvar testFillNodes = layoutTestUtils.testFillNodes;\nvar text = layoutTestUtils.text;\nvar texts = layoutTestUtils.texts;\nvar textSizes = layoutTestUtils.textSizes;\n\ndescribe('Javascript Only', function() {\n  it('should fill root node with layout, style, and children', function() {\n    testFillNodes(\n      {},\n      {layout: {width: undefined, height: undefined, top: 0, left: 0, right: 0, bottom: 0}, style: {}, children: []}\n    );\n  });\n  it('should fill root and child node with layout, style, and children', function() {\n    testFillNodes(\n      {children: [{}]},\n      {layout: {width: undefined, height: undefined, top: 0, left: 0, right: 0, bottom: 0}, style: {}, children: [\n        {layout: {width: undefined, height: undefined, top: 0, left: 0, right: 0, bottom: 0}, style: {}, children: []}\n      ]}\n    );\n  });\n  it('should not replace user-provided layout information', function() {\n    testFillNodes(\n      {layout: {width: 200}},\n      {layout: {width: 200}, style: {}, children: []}\n    );\n  });\n});\n\n\ndescribe('Layout', function() {\n  it('should layout a single node with width and height', function() {\n    testLayout({\n      style: {width: 100, height: 200}\n    }, {\n      width: 100, height: 200, top: 0, left: 0\n    });\n  });\n\n  it('should layout node with children', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000}, children: [\n        {style: {width: 500, height: 500}},\n        {style: {width: 250, height: 250}},\n        {style: {width: 125, height: 125}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 500, height: 500, top: 0, left: 0},\n        {width: 250, height: 250, top: 500, left: 0},\n        {width: 125, height: 125, top: 750, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with children in reverse', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, flexDirection: 'column-reverse'}, children: [\n        {style: {width: 500, height: 500}},\n        {style: {width: 250, height: 250}},\n        {style: {width: 125, height: 125}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 500, height: 500, top: 500, left: 0},\n        {width: 250, height: 250, top: 250, left: 0},\n        {width: 125, height: 125, top: 125, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with nested children', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000}, children: [\n        {style: {width: 500, height: 500}},\n        {style: {width: 500, height: 500}, children: [\n          {style: {width: 250, height: 250}},\n          {style: {width: 250, height: 250}}\n        ]}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 500, height: 500, top: 0, left: 0},\n        {width: 500, height: 500, top: 500, left: 0, children: [\n          {width: 250, height: 250, top: 0, left: 0},\n          {width: 250, height: 250, top: 250, left: 0}\n        ]}\n      ]}\n    );\n  });\n\n  it('should layout node with nested children in reverse', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, flexDirection: 'column-reverse'}, children: [\n        {style: {width: 500, height: 500}},\n        {style: {width: 500, height: 500, flexDirection: 'column-reverse'}, children: [\n          {style: {width: 250, height: 250}},\n          {style: {width: 250, height: 250}}\n        ]}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 500, height: 500, top: 500, left: 0},\n        {width: 500, height: 500, top: 0, left: 0, children: [\n          {width: 250, height: 250, top: 250, left: 0},\n          {width: 250, height: 250, top: 0, left: 0}\n        ]}\n      ]}\n    );\n  });\n\n  it('should layout node with margin', function() {\n    testLayout(\n      {style: {width: 100, height: 200, margin: 10}},\n      {width: 100, height: 200, top: 10, left: 10}\n    );\n  });\n\n  it('should layout node with several children', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, margin: 10}, children: [\n        {style: {width: 100, height: 100, margin: 50}},\n        {style: {width: 100, height: 100, margin: 25}},\n        {style: {width: 100, height: 100, margin: 10}}\n      ]},\n      {width: 1000, height: 1000, top: 10, left: 10, children: [\n        {width: 100, height: 100, top: 50, left: 50},\n        {width: 100, height: 100, top: 225, left: 25},\n        {width: 100, height: 100, top: 360, left: 10}\n      ]}\n    );\n  });\n\n  it('should layout node with several children in reverse', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, flexDirection: 'column-reverse', margin: 10}, children: [\n        {style: {width: 100, height: 100, margin: 50}},\n        {style: {width: 100, height: 100, margin: 25}},\n        {style: {width: 100, height: 100, margin: 10}}\n      ]},\n      {width: 1000, height: 1000, top: 10, left: 10, children: [\n        {width: 100, height: 100, top: 850, left: 50},\n        {width: 100, height: 100, top: 675, left: 25},\n        {width: 100, height: 100, top: 540, left: 10}\n      ]}\n    );\n  });\n\n  it('should layout rtl with reverse correctly', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, direction: 'rtl', flexDirection: 'row-reverse'}, children: [\n        {style: {width: 100, height: 200}},\n        {style: {width: 300, height: 150}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 100, height: 200, top: 0, left: 0},\n        {width: 300, height: 150, top: 0, left: 100}\n      ]}\n    );\n  });\n\n  it('should layout node with row flex direction', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, flexDirection: 'row'}, children: [\n        {style: {width: 100, height: 200}},\n        {style: {width: 300, height: 150}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 100, height: 200, top: 0, left: 0},\n        {width: 300, height: 150, top: 0, left: 100}\n      ]}\n    );\n  });\n\n  it('should layout node with row flex direction in rtl', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, direction: 'rtl', flexDirection: 'row'}, children: [\n        {style: {width: 100, height: 200}},\n        {style: {width: 300, height: 150}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 100, height: 200, top: 0, left: 900},\n        {width: 300, height: 150, top: 0, left: 600}\n      ]}\n    );\n  });\n\n  it('should layout node based on children main dimensions', function() {\n    testLayout(\n      {style: {width: 300}, children: [\n        {style: {width: 100, height: 200}},\n        {style: {width: 300, height: 150}}\n      ]},\n      {width: 300, height: 350, top: 0, left: 0, children: [\n        {width: 100, height: 200, top: 0, left: 0},\n        {width: 300, height: 150, top: 200, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node based on children main dimensions in reverse', function() {\n    testLayout(\n      {style: {width: 300, flexDirection: 'column-reverse'}, children: [\n        {style: {width: 100, height: 200}},\n        {style: {width: 300, height: 150}}\n      ]},\n      {width: 300, height: 350, top: 0, left: 0, children: [\n        {width: 100, height: 200, top: 150, left: 0},\n        {width: 300, height: 150, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with just flex', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000}, children: [\n        {style: {width: 100, height: 200}},\n        {style: {width: 100, flex: 1}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 100, height: 200, top: 0, left: 0},\n        {width: 100, height: 800, top: 200, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with just flex in reverse', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, flexDirection: 'column-reverse'}, children: [\n        {style: {width: 100, height: 200}},\n        {style: {width: 100, flex: 1}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 100, height: 200, top: 800, left: 0},\n        {width: 100, height: 800, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with flex recursively', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000}, children: [\n        {style: {width: 1000, flex: 1}, children: [\n          {style: {width: 1000, flex: 1}, children: [\n            {style: {width: 1000, flex: 1}}\n          ]}\n        ]}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 1000, height: 1000, top: 0, left: 0, children: [\n          {width: 1000, height: 1000, top: 0, left: 0, children: [\n            {width: 1000, height: 1000, top: 0, left: 0}\n          ]}\n        ]}\n      ]}\n    );\n  });\n\n  it('should layout node with flex recursively in reverse', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, flexDirection: 'column-reverse'}, children: [\n        {style: {width: 1000, flex: 1, flexDirection: 'column-reverse'}, children: [\n          {style: {width: 1000, flex: 1, flexDirection: 'column-reverse'}, children: [\n            {style: {width: 1000, flex: 1, flexDirection: 'column-reverse'}}\n          ]}\n        ]}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 1000, height: 1000, top: 0, left: 0, children: [\n          {width: 1000, height: 1000, top: 0, left: 0, children: [\n            {width: 1000, height: 1000, top: 0, left: 0}\n          ]}\n        ]}\n      ]}\n    );\n  });\n\n  it('should layout node with targeted margin', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, marginTop: 10, marginLeft: 5}, children: [\n        {style: {width: 100, height: 100, marginTop: 50, marginLeft: 15, marginBottom: 20}},\n        {style: {width: 100, height: 100, marginLeft: 30}}\n      ]},\n      {width: 1000, height: 1000, top: 10, left: 5, children: [\n        {width: 100, height: 100, top: 50, left: 15},\n        {width: 100, height: 100, top: 170, left: 30}\n      ]}\n    );\n  });\n\n  it('should layout node with targeted margin in reverse', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, flexDirection: 'column-reverse', marginTop: 10, marginLeft: 5}, children: [\n        {style: {width: 100, height: 100, marginTop: 50, marginLeft: 15, marginBottom: 20}},\n        {style: {width: 100, height: 100, marginLeft: 30}}\n      ]},\n      {width: 1000, height: 1000, top: 10, left: 5, children: [\n        {width: 100, height: 100, top: 880, left: 15},\n        {width: 100, height: 100, top: 730, left: 30}\n      ]}\n    );\n  });\n\n  it('should layout node with justifyContent: flex-start', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, justifyContent: 'flex-start'}, children: [\n        {style: {width: 100, height: 100}},\n        {style: {width: 100, height: 100}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 100, height: 100, top: 0, left: 0},\n        {width: 100, height: 100, top: 100, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with justifyContent: flex-start in reverse', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, flexDirection: 'column-reverse', justifyContent: 'flex-start'}, children: [\n        {style: {width: 100, height: 100}},\n        {style: {width: 100, height: 100}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 100, height: 100, top: 900, left: 0},\n        {width: 100, height: 100, top: 800, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with justifyContent: flex-end', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, justifyContent: 'flex-end'}, children: [\n        {style: {width: 100, height: 100}},\n        {style: {width: 100, height: 100}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 100, height: 100, top: 800, left: 0},\n        {width: 100, height: 100, top: 900, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with justifyContent: flex-end in reverse', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, flexDirection: 'column-reverse', justifyContent: 'flex-end'}, children: [\n        {style: {width: 100, height: 100}},\n        {style: {width: 100, height: 100}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 100, height: 100, top: 100, left: 0},\n        {width: 100, height: 100, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with justifyContent: space-between', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, justifyContent: 'space-between'}, children: [\n        {style: {width: 100, height: 100}},\n        {style: {width: 100, height: 100}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 100, height: 100, top: 0, left: 0},\n        {width: 100, height: 100, top: 900, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with justifyContent: space-between in reverse', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, flexDirection: 'column-reverse', justifyContent: 'space-between'}, children: [\n        {style: {width: 100, height: 100}},\n        {style: {width: 100, height: 100}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 100, height: 100, top: 900, left: 0},\n        {width: 100, height: 100, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with justifyContent: space-around', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, justifyContent: 'space-around'}, children: [\n        {style: {width: 100, height: 100}},\n        {style: {width: 100, height: 100}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 100, height: 100, top: 200, left: 0},\n        {width: 100, height: 100, top: 700, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with justifyContent: space-around in reverse', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, flexDirection: 'column-reverse', justifyContent: 'space-around'}, children: [\n        {style: {width: 100, height: 100}},\n        {style: {width: 100, height: 100}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 100, height: 100, top: 700, left: 0},\n        {width: 100, height: 100, top: 200, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with justifyContent: center', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, justifyContent: 'center'}, children: [\n        {style: {width: 100, height: 100}},\n        {style: {width: 100, height: 100}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 100, height: 100, top: 400, left: 0},\n        {width: 100, height: 100, top: 500, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with justifyContent: center in reverse', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, flexDirection: 'column-reverse', justifyContent: 'center'}, children: [\n        {style: {width: 100, height: 100}},\n        {style: {width: 100, height: 100}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 100, height: 100, top: 500, left: 0},\n        {width: 100, height: 100, top: 400, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with flex override height', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000}, children: [\n        {style: {width: 100, height: 100, flex: 1}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 100, height: 1000, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with alignItems: flex-start', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, alignItems: 'flex-start'}, children: [\n        {style: {width: 200, height: 100}},\n        {style: {width: 100, height: 100}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 200, height: 100, top: 0, left: 0},\n        {width: 100, height: 100, top: 100, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with alignItems: flex-start in reverse', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, flexDirection: 'column-reverse', alignItems: 'flex-start'}, children: [\n        {style: {width: 200, height: 100}},\n        {style: {width: 100, height: 100}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 200, height: 100, top: 900, left: 0},\n        {width: 100, height: 100, top: 800, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with alignItems: center', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, alignItems: 'center'}, children: [\n        {style: {width: 200, height: 100}},\n        {style: {width: 100, height: 100}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 200, height: 100, top: 0, left: 400},\n        {width: 100, height: 100, top: 100, left: 450}\n      ]}\n    );\n  });\n\n  it('should layout node with alignItems: center in reverse', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, flexDirection: 'column-reverse', alignItems: 'center'}, children: [\n        {style: {width: 200, height: 100}},\n        {style: {width: 100, height: 100}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 200, height: 100, top: 900, left: 400},\n        {width: 100, height: 100, top: 800, left: 450}\n      ]}\n    );\n  });\n\n  it('should layout node with alignItems: flex-end', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, alignItems: 'flex-end'}, children: [\n        {style: {width: 200, height: 100}},\n        {style: {width: 100, height: 100}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 200, height: 100, top: 0, left: 800},\n        {width: 100, height: 100, top: 100, left: 900}\n      ]}\n    );\n  });\n\n  it('should layout node with alignItems: flex-end in reverse', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, flexDirection: 'column-reverse', alignItems: 'flex-end'}, children: [\n        {style: {width: 200, height: 100}},\n        {style: {width: 100, height: 100}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 200, height: 100, top: 900, left: 800},\n        {width: 100, height: 100, top: 800, left: 900}\n      ]}\n    );\n  });\n\n  it('should layout node with alignSelf overrides alignItems', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, alignItems: 'flex-end'}, children: [\n        {style: {width: 200, height: 100}},\n        {style: {width: 100, height: 100, alignSelf: 'center'}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 200, height: 100, top: 0, left: 800},\n        {width: 100, height: 100, top: 100, left: 450}\n      ]}\n    );\n  });\n\n  it('should layout node with alignSelf overrides alignItems in reverse', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, flexDirection: 'column-reverse', alignItems: 'flex-end'}, children: [\n        {style: {width: 200, height: 100}},\n        {style: {width: 100, height: 100, alignSelf: 'center'}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 200, height: 100, top: 900, left: 800},\n        {width: 100, height: 100, top: 800, left: 450}\n      ]}\n    );\n  });\n\n  it('should layout node with alignItem: stretch', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, alignItems: 'stretch'}, children: [\n        {style: {height: 100}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 1000, height: 100, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with alignItem: stretch in reverse', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000, flexDirection: 'column-reverse', alignItems: 'stretch'}, children: [\n        {style: {height: 100}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 1000, height: 100, top: 900, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout empty node', function() {\n    testLayout(\n      {style: {}, children: [\n        {style: {}}\n      ]},\n      {width: 0, height: 0, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout empty node in reverse', function() {\n    testLayout(\n      {style: {flexDirection: 'column-reverse'}, children: [\n        {style: {}}\n      ]},\n      {width: 0, height: 0, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout child with margin', function() {\n    testLayout(\n      {style: {}, children: [\n        {style: {margin: 5}}\n      ]},\n      {width: 10, height: 10, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 5, left: 5}\n      ]}\n    );\n  });\n\n  it('should layout child with margin in reverse', function() {\n    testLayout(\n      {style: {flexDirection: 'column-reverse'}, children: [\n        {style: {margin: 5}}\n      ]},\n      {width: 10, height: 10, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 5, left: 5}\n      ]}\n    );\n  });\n\n  it('should not shrink children if not enough space', function() {\n    testLayout(\n      {style: {height: 100}, children: [\n        {style: {height: 100}},\n        {style: {height: 200}}\n      ]},\n      {width: 0, height: 100, top: 0, left: 0, children: [\n        {width: 0, height: 100, top: 0, left: 0},\n        {width: 0, height: 200, top: 100, left: 0}\n      ]}\n    );\n  });\n\n  it('should not shrink children if not enough space in reverse', function() {\n    testLayout(\n      {style: {height: 100, flexDirection: 'column-reverse'}, children: [\n        {style: {height: 100}},\n        {style: {height: 200}}\n      ]},\n      {width: 0, height: 100, top: 0, left: 0, children: [\n        {width: 0, height: 100, top: 0, left: 0},\n        {width: 0, height: 200, top: -200, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout for center', function() {\n    testLayout(\n      {style: {justifyContent: 'center'}},\n      {width: 0, height: 0, top: 0, left: 0}\n    );\n  });\n\n  it('should layout flex-end taking into account margin', function() {\n    testLayout(\n      {style: {height: 100, justifyContent: 'flex-end'}, children: [\n        {style: {marginTop: 10}}\n      ]},\n      {width: 0, height: 100, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 100, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout flex-end taking into account margin in reverse', function() {\n    testLayout(\n      {style: {height: 100, flexDirection: 'column-reverse', justifyContent: 'flex-end'}, children: [\n        {style: {marginTop: 10}}\n      ]},\n      {width: 0, height: 100, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 10, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout alignItems with margin', function() {\n    testLayout(\n      {style: {}, children: [\n        {style: {alignItems: 'flex-end'}, children: [\n          {style: {margin: 10}},\n          {style: {height: 100}}\n        ]}\n      ]},\n      {width: 20, height: 120, top: 0, left: 0, children: [\n        {width: 20, height: 120, top: 0, left: 0, children: [\n          {width: 0, height: 0, top: 10, left: 10},\n          {width: 0, height: 100, top: 20, left: 20}\n        ]}\n      ]}\n    );\n  });\n\n  it('should layout alignItems with margin in reverse', function() {\n    testLayout(\n      {style: {}, children: [\n        {style: {flexDirection: 'column-reverse', alignItems: 'flex-end'}, children: [\n          {style: {margin: 10}},\n          {style: {height: 100}}\n        ]}\n      ]},\n      {width: 20, height: 120, top: 0, left: 0, children: [\n        {width: 20, height: 120, top: 0, left: 0, children: [\n          {width: 0, height: 0, top: 110, left: 10},\n          {width: 0, height: 100, top: 0, left: 20}\n        ]}\n      ]}\n    );\n  });\n\n  it('should layout flex inside of an empty element', function() {\n    testLayout(\n      {style: {}, children: [\n        {style: {flex: 1}}\n      ]},\n      {width: 0, height: 0, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout alignItems stretch and margin', function() {\n    testLayout(\n      {style: {alignItems: 'stretch'}, children: [\n        {style: {marginLeft: 10}}\n      ]},\n      {width: 10, height: 0, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 0, left: 10}\n      ]}\n    );\n  });\n\n  it('should layout alignItems stretch and margin in reverse', function() {\n    testLayout(\n      {style: {flexDirection: 'column-reverse', alignItems: 'stretch'}, children: [\n        {style: {marginLeft: 10}}\n      ]},\n      {width: 10, height: 0, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 0, left: 10}\n      ]}\n    );\n  });\n\n  it('should layout node with padding', function() {\n    testLayout(\n      {style: {padding: 5}},\n      {width: 10, height: 10, top: 0, left: 0}\n    );\n  });\n\n  it('should layout node with padding and a child', function() {\n    testLayout(\n      {style: {padding: 5}, children: [\n        {style: {}}\n      ]},\n      {width: 10, height: 10, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 5, left: 5}\n      ]}\n    );\n  });\n\n  it('should layout node with padding and a child with margin', function() {\n    testLayout(\n      {style: {padding: 5}, children: [\n        {style: {margin: 5}}\n      ]},\n      {width: 20, height: 20, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 10, left: 10}\n      ]}\n    );\n  });\n\n  it('should layout node with padding and stretch', function() {\n    testLayout(\n      {style: {}, children: [\n        {style: {padding: 10, alignSelf: 'stretch'}}\n      ]},\n      {width: 20, height: 20, top: 0, left: 0, children: [\n        {width: 20, height: 20, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with inner & outer padding and stretch', function() {\n    testLayout(\n      {style: {padding: 50}, children: [\n        {style: {padding: 10, alignSelf: 'stretch'}}\n      ]},\n      {width: 120, height: 120, top: 0, left: 0, children: [\n        {width: 20, height: 20, top: 50, left: 50}\n      ]}\n    );\n  });\n\n  it('should layout node with stretch and child with margin', function() {\n    testLayout(\n      {style: {}, children: [\n        {style: {alignSelf: 'stretch'}, children: [\n          {style: {margin: 16}}\n        ]}\n      ]},\n      {width: 32, height: 32, top: 0, left: 0, children: [\n        {width: 32, height: 32, top: 0, left: 0, children: [\n          {width: 0, height: 0, top: 16, left: 16}\n        ]}\n      ]}\n    );\n  });\n\n  it('should layout node with top and left', function() {\n    testLayout(\n      {style: {top: 5, left: 5}},\n      {width: 0, height: 0, top: 5, left: 5}\n    );\n  });\n\n  it('should layout node with height, padding and space-around', function() {\n    testLayout(\n      {style: {height: 10, paddingTop: 5, justifyContent: 'space-around'}, children: [\n        {style: {}}\n      ]},\n      {width: 0, height: 10, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 7.5, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with bottom', function() {\n    testLayout(\n      {style: {bottom: 5}},\n      {width: 0, height: 0, top: -5, left: 0}\n    );\n  });\n\n  it('should layout node with both top and bottom', function() {\n    testLayout(\n      {style: {top: 10, bottom: 5}},\n      {width: 0, height: 0, top: 10, left: 0}\n    );\n  });\n\n  it('should layout node with position: absolute', function() {\n    testLayout(\n      {style: {width: 500, flexDirection: 'row'}, children: [\n        {style: {flex: 1}},\n        {style: {position: 'absolute', width: 50}},\n        {style: {flex: 1}}\n      ]},\n      {width: 500, height: 0, top: 0, left: 0, children: [\n        {width: 250, height: 0, top: 0, left: 0},\n        {width: 50, height: 0, top: 0, left: 250},\n        {width: 250, height: 0, top: 0, left: 250}\n      ]}\n    );\n  });\n\n  it('should layout node with child with position: absolute and margin', function() {\n    testLayout(\n      {style: {}, children: [\n        {style: {marginRight: 15, position: 'absolute'}}\n      ]},\n      {width: 0, height: 0, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with position: absolute, padding and alignSelf: center', function() {\n    testLayout(\n      {style: {}, children: [\n        {style: {paddingRight: 12, alignSelf: 'center', position: 'absolute'}}\n      ]},\n      {width: 0, height: 0, top: 0, left: 0, children: [\n        {width: 12, height: 0, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should work with height smaller than paddingBottom', function() {\n    testLayout(\n      {style: {height: 5, paddingBottom: 20}},\n      {width: 0, height: 20, top: 0, left: 0}\n    );\n  });\n\n  it('should work with width smaller than paddingLeft', function() {\n    testLayout(\n      {style: {width: 5, paddingLeft: 20}},\n      {width: 20, height: 0, top: 0, left: 0}\n    );\n  });\n\n  it('should layout node with specified width and stretch', function() {\n    testLayout(\n      {style: {}, children: [{\n        style: {}, children: [\n          {style: {width: 400}}\n        ]},\n        {style: {width: 200, alignSelf: 'stretch'}}\n      ]},\n      {width: 400, height: 0, top: 0, left: 0, children: [\n        {width: 400, height: 0, top: 0, left: 0, children: [\n          {width: 400, height: 0, top: 0, left: 0}\n        ]},\n        {width: 200, height: 0, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with padding and child with position absolute', function() {\n    testLayout(\n      {style: {padding: 5}, children: [\n        {style: {position: 'absolute'}}\n      ]},\n      {width: 10, height: 10, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 5, left: 5}\n      ]}\n    );\n  });\n\n  it('should layout node with position absolute, top and left', function() {\n    testLayout(\n      {style: {}, children: [\n        {style: {height: 100}},\n        {style: {position: 'absolute', top: 10, left: 10}}\n      ]},\n      {width: 0, height: 100, top: 0, left: 0, children: [\n        {width: 0, height: 100, top: 0, left: 0},\n        {width: 0, height: 0, top: 10, left: 10}\n      ]}\n    );\n  });\n\n  it('should layout node with padding and child position absolute, left', function() {\n    testLayout(\n      {style: {padding: 20}, children: [\n        {style: {left: 5, position: 'absolute'}}\n      ]},\n      {width: 40, height: 40, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 20, left: 5}\n      ]}\n    );\n  });\n\n  it('should layout node with position: absolute, top and marginTop', function() {\n    testLayout(\n      {style: {}, children: [\n        {style: {top: 5, marginTop: 5, position: 'absolute'}}\n      ]},\n      {width: 0, height: 0, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 10, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with position: absolute, left and marginLeft', function() {\n    testLayout(\n      {style: {}, children: [\n        {style: {left: 5, marginLeft: 5, position: 'absolute'}}\n      ]},\n      {width: 0, height: 0, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 0, left: 10}\n      ]}\n    );\n  });\n\n  it('should layout node with space-around and child position absolute', function() {\n    testLayout(\n      {style: {height: 200, justifyContent: 'space-around'}, children: [\n        {style: {position: 'absolute'}},\n        {style: {}}\n      ]},\n      {width: 0, height: 200, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 100, left: 0},\n        {width: 0, height: 0, top: 100, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with space-around and child position absolute in reverse', function() {\n    testLayout(\n      {style: {height: 200, flexDirection: 'column-reverse', justifyContent: 'space-around'}, children: [\n        {style: {position: 'absolute'}},\n        {style: {}}\n      ]},\n      {width: 0, height: 200, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 100, left: 0},\n        {width: 0, height: 0, top: 100, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with flex and main margin', function() {\n    testLayout(\n      {style: {width: 700, flexDirection: 'row'}, children: [\n        {style: {marginLeft: 5, flex: 1}}\n      ]},\n      {width: 700, height: 0, top: 0, left: 0, children: [\n        {width: 695, height: 0, top: 0, left: 5}\n      ]}\n    );\n  });\n\n  it('should layout node with flex and main margin in rtl', function() {\n    testLayout(\n      {style: {width: 700, direction: 'rtl', flexDirection: 'row'}, children: [\n        {style: {marginRight: 5, flex: 1}}\n      ]},\n      {width: 700, height: 0, top: 0, left: 0, children: [\n        {width: 695, height: 0, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with multiple flex and padding', function() {\n    testLayout(\n      {style: {width: 700, flexDirection: 'row'}, children: [\n        {style: {flex: 1}},\n        {style: {paddingRight: 5, flex: 1}}\n      ]},\n      {width: 700, height: 0, top: 0, left: 0, children: [\n        {width: 347.5, height: 0, top: 0, left: 0},\n        {width: 352.5, height: 0, top: 0, left: 347.5}\n      ]}\n    );\n  });\n\n  it('should layout node with multiple flex and padding in rtl', function() {\n    testLayout(\n      {style: {width: 700, direction: 'rtl', flexDirection: 'row'}, children: [\n        {style: {flex: 1}},\n        {style: {paddingLeft: 5, flex: 1}}\n      ]},\n      {width: 700, height: 0, top: 0, left: 0, children: [\n        {width: 347.5, height: 0, top: 0, left: 352.5},\n        {width: 352.5, height: 0, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with multiple flex and margin', function() {\n    testLayout(\n      {style: {width: 700, flexDirection: 'row'}, children: [\n        {style: {flex: 1}},\n        {style: {marginLeft: 5, flex: 1}}\n      ]},\n      {width: 700, height: 0, top: 0, left: 0, children: [\n        {width: 347.5, height: 0, top: 0, left: 0},\n        {width: 347.5, height: 0, top: 0, left: 352.5}\n      ]}\n    );\n  });\n\n  it('should layout node with multiple flex and margin in rtl', function() {\n    testLayout(\n      {style: {width: 700, direction: 'rtl', flexDirection: 'row'}, children: [\n        {style: {flex: 1}},\n        {style: {marginRight: 5, flex: 1}}\n      ]},\n      {width: 700, height: 0, top: 0, left: 0, children: [\n        {width: 347.5, height: 0, top: 0, left: 352.5},\n        {width: 347.5, height: 0, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with flex and overflow', function() {\n    testLayout(\n      {style: {height: 300}, children: [\n        {style: {height: 600}},\n        {style: {flex: 1}}\n      ]},\n      {width: 0, height: 300, top: 0, left: 0, children: [\n        {width: 0, height: 600, top: 0, left: 0},\n        {width: 0, height: 0, top: 600, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with flex and position absolute', function() {\n    testLayout(\n      {style: {width: 600, flexDirection: 'row'}, children: [\n        {style: {flex: 1, position: 'absolute'}}\n      ]},\n      {width: 600, height: 0, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with flex and position absolute in rtl', function() {\n    testLayout(\n      {style: {width: 600, direction: 'rtl', flexDirection: 'row'}, children: [\n        {style: {flex: 1, position: 'absolute'}}\n      ]},\n      {width: 600, height: 0, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 0, left: 600}\n      ]}\n    );\n  });\n\n  it('should layout node with double flex and position absolute', function() {\n    testLayout(\n      {style: {height: 500}, children: [\n        {style: {flex: 1}},\n        {style: {flex: 1, position: 'absolute'}}\n      ]},\n      {width: 0, height: 500, top: 0, left: 0, children: [\n        {width: 0, height: 500, top: 0, left: 0},\n        {width: 0, height: 0, top: 500, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with borderWidth', function() {\n    testLayout(\n      {style: {borderWidth: 5}},\n      {width: 10, height: 10, top: 0, left: 0}\n    );\n  });\n\n  it('should layout node with borderWidth and position: absolute, top', function() {\n    testLayout(\n      {style: {borderTopWidth: 1}, children: [\n        {style: {top: -1, position: 'absolute'}}\n      ]},\n      {width: 0, height: 1, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with borderWidth and position: absolute, top. cross axis', function() {\n    testLayout(\n      {style: {borderWidth: 1}, children: [\n        {style: {left: 5, position: 'absolute'}}\n      ]},\n      {width: 2, height: 2, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 1, left: 6}\n      ]}\n    );\n  });\n\n  it('should correctly take into account min padding for stretch', function() {\n    testLayout(\n      {style: {width: 50}, children: [\n        {style: {marginLeft: 20, padding: 20, alignSelf: 'stretch'}}\n      ]},\n      {width: 50, height: 40, top: 0, left: 0, children: [\n        {width: 40, height: 40, top: 0, left: 20}\n      ]}\n    );\n  });\n\n  it('should layout node with negative width', function() {\n    testLayout(\n      {style: {width: -31}, children: [\n        {style: {borderRightWidth: 5}}\n      ]},\n      {width: 5, height: 0, top: 0, left: 0, children: [\n        {width: 5, height: 0, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should handle negative margin and min padding correctly', function() {\n    testLayout(\n      {style: {borderRightWidth: 1, flexDirection: 'row'}, children: [\n        {style: {marginRight: -8}}\n      ]},\n      {width: 1, height: 0, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should handle negative margin and min padding correctly in rtl', function() {\n    testLayout(\n      {style: {borderLeftWidth: 1, direction: 'rtl', flexDirection: 'row'}, children: [\n        {style: {marginLeft: -8}}\n      ]},\n      {width: 1, height: 0, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 0, left: 1}\n      ]}\n    );\n  });\n\n  it('should layout node with just text', function() {\n    testLayout(\n      {style: {measure: text(texts.small)}},\n      {width: textSizes.smallWidth, height: textSizes.smallHeight, top: 0, left: 0}\n    );\n  });\n\n  it('should layout node with text and width', function() {\n    testLayout(\n      {style: {measure: text(texts.small), width: 10}},\n      {width: 10, height: textSizes.smallHeight, top: 0, left: 0}\n    );\n  });\n\n  it('should layout node with text, padding and margin', function() {\n    testLayout(\n      {style: {measure: text(texts.big)}},\n      {width: textSizes.bigWidth, height: textSizes.smallHeight, top: 0, left: 0}\n    );\n  });\n\n  it('should layout node with nested alignSelf: stretch', function() {\n    testLayout(\n      {style: {width: 300}, children: [\n        {style: {alignSelf: 'stretch'}, children: [\n          {style: {alignSelf: 'stretch'}}\n        ]}\n      ]},\n      {width: 300, height: 0, top: 0, left: 0, children: [\n        {width: 300, height: 0, top: 0, left: 0, children: [\n          {width: 300, height: 0, top: 0, left: 0}\n        ]}\n      ]}\n    );\n  });\n\n  it('should layout node with text and flex', function() {\n    testLayout(\n      {style: {}, children: [\n        {style: {width: 500, flexDirection: 'row'}, children: [\n          {style: {flex: 1, measure: text(texts.big)}}\n        ]}\n      ]},\n      {width: 500, height: textSizes.smallHeight, top: 0, left: 0, children: [\n        {width: 500, height: textSizes.smallHeight, top: 0, left: 0, children: [\n          {width: 500, height: textSizes.smallHeight, top: 0, left: 0}\n        ]}\n      ]}\n    );\n  });\n\n  it('should layout node with text and flex in rtl', function() {\n    testLayout(\n      {style: {}, children: [\n        {style: {width: 500, direction: 'rtl', flexDirection: 'row'}, children: [\n          {style: {flex: 1, measure: text(texts.big)}}\n        ]}\n      ]},\n      {width: 500, height: textSizes.smallHeight, top: 0, left: 0, children: [\n        {width: 500, height: textSizes.smallHeight, top: 0, left: 0, children: [\n          {width: 500, height: textSizes.smallHeight, top: 0, left: 0}\n        ]}\n      ]}\n    );\n  });\n\n  it('should layout node with text and stretch', function() {\n    testLayout(\n      {style: {width: 130}, children: [\n        {style: {alignSelf: 'stretch', alignItems: 'stretch'}, children: [\n          {style: {measure: text(texts.big)}}\n        ]}\n      ]},\n      {width: 130, height: textSizes.bigHeight, top: 0, left: 0, children: [\n        {width: 130, height: textSizes.bigHeight, top: 0, left: 0, children: [\n          {width: 130, height: textSizes.bigHeight, top: 0, left: 0}\n        ]}\n      ]}\n    );\n  });\n\n  it('should layout node with text stretch and width', function() {\n    testLayout(\n      {style: {width: 200}, children: [\n        {style: {alignSelf: 'stretch', alignItems: 'stretch'}, children: [\n          {style: {width: 130, measure: text(texts.big)}}\n        ]}\n      ]},\n      {width: 200, height: textSizes.bigHeight, top: 0, left: 0, children: [\n        {width: 200, height: textSizes.bigHeight, top: 0, left: 0, children: [\n          {width: 130, height: textSizes.bigHeight, top: 0, left: 0}\n        ]}\n      ]}\n    );\n  });\n\n  it('should layout node with text bounded by parent', function() {\n    testLayout(\n      {style: {width: 100, alignSelf: 'flex-start'}, children: [\n        {style: {measure: text(texts.big), alignSelf: 'flex-start'}}\n      ]},\n      {width: 100, height: textSizes.bigHeight, top: 0, left: 0, children: [\n        {width: textSizes.bigMinWidth, height: textSizes.bigHeight, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout node with text bounded by grand-parent', function() {\n    testLayout(\n      {style: {width: 100, padding: 10, alignSelf: 'flex-start'}, children: [\n        {style: {margin: 10, alignSelf: 'flex-start'}, children: [\n          {style: {measure: text(texts.big)}}\n        ]}\n      ]},\n      {width: 100, height: 40 + textSizes.bigHeight, top: 0, left: 0, children: [\n        {width: textSizes.bigMinWidth, height: textSizes.bigHeight, top: 20, left: 20, children: [\n          {width: textSizes.bigMinWidth, height: textSizes.bigHeight, top: 0, left: 0}\n        ]}\n      ]}\n    );\n  });\n\n  it('should layout space-between when remaining space is negative', function() {\n    testLayout(\n      {style: {height: 100, justifyContent: 'space-between'}, children: [\n        {style: {height: 900}},\n        {style: {}}\n      ]},\n      {width: 0, height: 100, top: 0, left: 0, children: [\n        {width: 0, height: 900, top: 0, left: 0},\n        {width: 0, height: 0, top: 900, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout space-between when remaining space is negative in reverse', function() {\n    testLayout(\n      {style: {height: 100, flexDirection: 'column-reverse', justifyContent: 'space-between'}, children: [\n        {style: {height: 900}},\n        {style: {}}\n      ]},\n      {width: 0, height: 100, top: 0, left: 0, children: [\n        {width: 0, height: 900, top: -800, left: 0},\n        {width: 0, height: 0, top: -800, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout flex-end when remaining space is negative', function() {\n    testLayout(\n      {style: {width: 200, flexDirection: 'row', justifyContent: 'flex-end'}, children: [\n        {style: {width: 900}}\n      ]},\n      {width: 200, height: 0, top: 0, left: 0, children: [\n        {width: 900, height: 0, top: 0, left: -700}\n      ]}\n    );\n  });\n\n  it('should layout flex-end when remaining space is negative in rtl', function() {\n    testLayout(\n      {style: {width: 200, direction: 'rtl', flexDirection: 'row', justifyContent: 'flex-end'}, children: [\n        {style: {width: 900}}\n      ]},\n      {width: 200, height: 0, top: 0, left: 0, children: [\n        {width: 900, height: 0, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout text with flexDirection row', function() {\n    testLayout(\n      {style: {}, children: [\n        {style: {width: 200, flexDirection: 'row'}, children: [\n          {style: {margin: 20, measure: text(texts.big)}}\n        ]}\n      ]},\n      {width: 200, height: textSizes.smallHeight + 40, top: 0, left: 0, children: [\n        {width: 200, height: textSizes.smallHeight + 40, top: 0, left: 0, children: [\n          {width: textSizes.bigWidth, height: textSizes.smallHeight, top: 20, left: 20}\n        ]}\n      ]}\n    );\n  });\n\n  it('should layout text with flexDirection row in rtl', function() {\n    testLayout(\n      {style: { direction: 'rtl' }, children: [\n        {style: {width: 200, flexDirection: 'row'}, children: [\n          {style: {margin: 20, measure: text(texts.big)}}\n        ]}\n      ]},\n      {width: 200, height: textSizes.smallHeight + 40, top: 0, left: 0, children: [\n        {width: 200, height: textSizes.smallHeight + 40, top: 0, left: 0, children: [\n          {width: textSizes.bigWidth, height: textSizes.smallHeight, top: 20, left: 8}\n        ]}\n      ]}\n    );\n  });\n\n  it('should layout with text and margin', function() {\n    testLayout(\n      {style: {}, children: [\n        {style: {width: 200}, children: [\n          {style: {margin: 20, measure: text(texts.big)}}\n        ]}\n      ]},\n      {width: 200, height: textSizes.bigHeight + 40, top: 0, left: 0, children: [\n        {width: 200, height: textSizes.bigHeight + 40, top: 0, left: 0, children: [\n          {width: 160, height: textSizes.bigHeight, top: 20, left: 20}\n        ]}\n      ]}\n    );\n  });\n\n  it('should layout with position absolute, top, left, bottom, right', function() {\n    testLayout(\n      {style: {width: 100, height: 100}, children: [\n        {style: {position: 'absolute', top: 0, left: 0, bottom: 0, right: 0}}\n      ]},\n      {width: 100, height: 100, top: 0, left: 0, children: [\n        {width: 100, height: 100, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout with arbitrary flex', function() {\n    testLayout(\n      {style: {width: 100, height: 100, alignSelf: 'flex-start'}, children: [\n        {style: {flex: 2.5, alignSelf: 'flex-start'}},\n        {style: {flex: 7.5, alignSelf: 'flex-start'}}\n      ]},\n      {width: 100, height: 100, top: 0, left: 0, children: [\n        {width: 0, height: 25, top: 0, left: 0},\n        {width: 0, height: 75, top: 25, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout with arbitrary flex in reverse', function() {\n    testLayout(\n      {style: {width: 100, height: 100, flexDirection: 'column-reverse', alignSelf: 'flex-start'}, children: [\n        {style: {flex: 2.5, alignSelf: 'flex-start'}},\n        {style: {flex: 7.5, alignSelf: 'flex-start'}}\n      ]},\n      {width: 100, height: 100, top: 0, left: 0, children: [\n        {width: 0, height: 25, top: 75, left: 0},\n        {width: 0, height: 75, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout with negative flex in reverse', function() {\n    testLayout(\n      {style: {width: 100, height: 100, flexDirection: 'column-reverse', alignSelf: 'flex-start'}, children: [\n        {style: {flex: -2.5, alignSelf: 'flex-start'}},\n        {style: {flex: 0, alignSelf: 'flex-start'}}\n      ]},\n      {width: 100, height: 100, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 100, left: 0},\n        {width: 0, height: 0, top: 100, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout with position: absolute and another sibling', function() {\n    testLayout(\n      {style: {}, children: [\n        {style: {width: 50, height: 100}},\n        {style: {position: 'absolute', left: 0, right: 0}}\n      ]},\n      {width: 50, height: 100, top: 0, left: 0, children: [\n        {width: 50, height: 100, top: 0, left: 0},\n        {width: 50, height: 0, top: 100, left: 0}\n      ]}\n    );\n  });\n\n  it('should calculate height properly with position: absolute top and bottom', function() {\n    testLayout(\n      {style: {height: 100}, children: [\n        {style: {position: 'absolute', top: 0, bottom: 20}}\n      ]},\n      {width: 0, height: 100, top: 0, left: 0, children: [\n        {width: 0, height: 80, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout with complicated position: absolute and justifyContent: center combo', function() {\n    testLayout(\n      {style: {width: 200, height: 200}, children: [\n        {style: {position: 'absolute', justifyContent: 'center', top: 0, left: 0, right: 0, bottom: 0}, children: [\n          {style: {width: 100, height: 100}}\n        ]}\n      ]},\n      {width: 200, height: 200, top: 0, left: 0, children: [\n        {width: 200, height: 200, top: 0, left: 0, children: [\n          {width: 100, height: 100, top: 50, left: 0}\n        ]}\n      ]}\n    );\n  });\n\n  it('should calculate top properly with position: absolute bottom', function() {\n    testLayout(\n      {style: {height: 100}, children: [\n        {style: {position: 'absolute', bottom: 0}}\n      ]},\n      {width: 0, height: 100, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 100, left: 0}\n      ]}\n    );\n  });\n\n  it('should calculate left properly with position: absolute right', function() {\n    testLayout(\n      {style: {width: 100}, children: [\n        {style: {position: 'absolute', right: 0}}\n      ]},\n      {width: 100, height: 0, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 0, left: 100}\n      ]}\n    );\n  });\n\n  it('should calculate top properly with position: absolute bottom and height', function() {\n    testLayout(\n      {style: {height: 100}, children: [\n        {style: {height: 10, position: 'absolute', bottom: 0}}\n      ]},\n      {width: 0, height: 100, top: 0, left: 0, children: [\n        {width: 0, height: 10, top: 90, left: 0}\n      ]}\n    );\n  });\n\n  it('should calculate left properly with position: absolute right and width', function() {\n    testLayout(\n      {style: {width: 100}, children: [\n        {style: {width: 10, position: 'absolute', right: 0}}\n      ]},\n      {width: 100, height: 0, top: 0, left: 0, children: [\n        {width: 10, height: 0, top: 0, left: 90}\n      ]}\n    );\n  });\n\n  it('should calculate top properly with position: absolute right, width, and no parent dimensions', function() {\n    testLayout(\n      {style: {}, children: [\n        {style: {height: 10, position: 'absolute', bottom: 0}}\n      ]},\n      {width: 0, height: 0, top: 0, left: 0, children: [\n        {width: 0, height: 10, top: -10, left: 0}\n      ]}\n    );\n  });\n\n  it('should calculate left properly with position: absolute right, width, and no parent dimensions', function() {\n    testLayout(\n      {style: {}, children: [\n        {style: {width: 10, position: 'absolute', right: 0}}\n      ]},\n      {width: 0, height: 0, top: 0, left: 0, children: [\n        {width: 10, height: 0, top: 0, left: -10}\n      ]}\n    );\n  });\n\n  it('should layout border bottom inside of justify content space between container', function() {\n    testLayout(\n      {style: {justifyContent: 'space-between'}, children: [\n        {style: {borderBottomWidth: 1}}\n      ]},\n      {width: 0, height: 1, top: 0, left: 0, children: [\n        {width: 0, height: 1, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout negative margin top inside of justify content center container', function() {\n    testLayout(\n      {style: {justifyContent: 'center'}, children: [\n        {style: {marginTop: -6}}\n      ]},\n      {width: 0, height: 0, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: -3, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout positive margin top inside of justify content center container', function() {\n    testLayout(\n      {style: {justifyContent: 'center'}, children: [\n        {style: {marginTop: 20}}\n      ]},\n      {width: 0, height: 20, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 20, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout border bottom and flex end with an empty child', function() {\n    testLayout(\n      {style: {borderBottomWidth: 5, justifyContent: 'flex-end'}, children: [\n        {style: {}}\n      ]},\n      {width: 0, height: 5, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout with children of a contain with left', function() {\n    testLayout(\n      {style: {width: 800}, children: [\n        {style: {left: 5}, children: [\n          {style: {}}\n        ]}\n      ]},\n      {width: 800, height: 0, top: 0, left: 0, children: [\n        {width: 800, height: 0, top: 0, left: 5, children: [\n          {width: 800, height: 0, top: 0, left: 0}\n        ]}\n      ]}\n    );\n  });\n\n  // This behavior is very weird. The child has a width of 0 but somehow the\n  // parent has a width of 500. Looks like a bug rather than a feature.\n  // https://code.google.com/p/chromium/issues/detail?id=441768\n  xit('should layout with flex: 0 and a specific width', function() {\n    testLayout(\n      {style: {flexDirection: 'row'}, children: [\n        {style: {width: 500, flex: 0}}\n      ]},\n      {width: 500, height: 0, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  xit('should layout with nested padding', function() {\n    testLayout(\n      {style: {}, children: [\n        {style: {}, children: [\n          {style: {}}\n        ]},\n        {style: {padding: 5}}\n      ]},\n      {width: 10, height: 10, top: 0, left: 0, children: [\n        {width: 10, height: 0, top: 0, left: 0, children: [\n          {width: 10, height: 0, top: 0, left: 0}\n        ]},\n        {width: 10, height: 10, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout flex-wrap', function() {\n    testLayout(\n      {style: {flexWrap: 'wrap', flexDirection: 'row', width: 100}, children: [\n        {style: {width: 40, height: 10}},\n        {style: {width: 40, height: 10}},\n        {style: {width: 40, height: 10}}\n      ]},\n      {width: 100, height: 20, top: 0, left: 0, children: [\n        {width: 40, height: 10, top: 0, left: 0},\n        {width: 40, height: 10, top: 0, left: 40},\n        {width: 40, height: 10, top: 10, left: 0}\n      ]}\n    );\n  });\n\n  it('should layout flex-wrap in rtl', function() {\n    testLayout(\n      {style: {flexWrap: 'wrap', direction: 'rtl', flexDirection: 'row', width: 100}, children: [\n        {style: {width: 40, height: 10}},\n        {style: {width: 40, height: 10}},\n        {style: {width: 40, height: 10}}\n      ]},\n      {width: 100, height: 20, top: 0, left: 0, children: [\n        {width: 40, height: 10, top: 0, left: 60},\n        {width: 40, height: 10, top: 0, left: 20},\n        {width: 40, height: 10, top: 10, left: 60}\n      ]}\n    );\n  });\n\n  it('should layout flex wrap with a line bigger than container', function() {\n    testLayout(\n      {style: {height: 100, flexWrap: 'wrap'}, children: [\n        {style: {height: 100}},\n        {style: {height: 200}}\n      ]},\n      {width: 0, height: 100, top: 0, left: 0, children: [\n        {width: 0, height: 100, top: 0, left: 0},\n        {width: 0, height: 200, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  // The container should be width = 25 because the width of the two children\n  // are 20 and 5. It's likely a bug in Chrome\n  // https://code.google.com/p/chromium/issues/detail?id=247963#c16\n  xit('should layout flex wrap with padding and borders', function() {\n    testLayout(\n      {style: {height: 100, flexWrap: 'wrap'}, children: [\n        {style: {height: 500, paddingRight: 20}},\n        {style: {borderLeftWidth: 5}}\n      ]},\n      {width: 20, height: 100, top: 0, left: 0, children: [\n        {width: 20, height: 500, top: 0, left: 0},\n        {width: 5, height: 0, top: 0, left: 20}\n      ]}\n    );\n  });\n\n\n  xit('should layout text with alignItems: stretch', function() {\n    testLayout(\n      {style: {width: 80, padding: 7, alignItems: 'stretch', measure: text(texts.big)}},\n      {width: 80, height: 68, top: 0, left: 0}\n    );\n  });\n\n  xit('should layout node with text and position absolute', function() {\n    testLayout(\n      {style: {}, children: [\n        {style: {measure: text(texts.big)}}\n      ]},\n      {width: 0, height: 0, top: 0, left: 0, children: [\n        {width: 100, height: textSizes.bigHeight, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should use max bounds', function() {\n    testLayout(\n      {style: {width: 100, height: 200, maxWidth: 90, maxHeight: 190}},\n      {width: 90, height: 190, top: 0, left: 0}\n    );\n  });\n\n  it('should use min bounds', function() {\n    testLayout(\n      {style: {width: 100, height: 200, minWidth: 110, minHeight: 210}},\n      {width: 110, height: 210, top: 0, left: 0}\n    );\n  });\n\n  it('should use min bounds over max bounds', function() {\n    testLayout(\n      {style: {width: 100, height: 200, minWidth: 110, maxWidth: 90, minHeight: 210, maxHeight: 190}},\n      {width: 110, height: 210, top: 0, left: 0}\n    );\n  });\n\n  it('should use min bounds over max bounds and natural width', function() {\n    testLayout(\n      {style: {width: 100, height: 200, minWidth: 90, maxWidth: 80, minHeight: 190, maxHeight: 180}},\n      {width: 90, height: 190, top: 0, left: 0}\n    );\n  });\n\n  it('should ignore negative min bounds', function() {\n    testLayout(\n      {style: {width: 100, height: 200, minWidth: -10, minHeight: -20}},\n      {width: 100, height: 200, top: 0, left: 0}\n    );\n  });\n\n  it('should ignore negative max bounds', function() {\n    testLayout(\n      {style: {width: 100, height: 200, maxWidth: -10, maxHeight: -20}},\n      {width: 100, height: 200, top: 0, left: 0}\n    );\n  });\n\n  it('should use padded size over max bounds', function() {\n    testLayout(\n      {style: {paddingTop: 15, paddingBottom: 15, paddingLeft: 20, paddingRight: 20, maxWidth: 30, maxHeight: 10}},\n      {width: 40, height: 30, top: 0, left: 0}\n    );\n  });\n\n  it('should use min size over padded size', function() {\n    testLayout(\n      {style: {paddingTop: 15, paddingBottom: 15, paddingLeft: 20, paddingRight: 20, minWidth: 50, minHeight: 40}},\n      {width: 50, height: 40, top: 0, left: 0}\n    );\n  });\n\n  it('should override flex direction size with min bounds', function() {\n    testLayout(\n      {style: {width: 300, height: 200, flexDirection: 'row'}, children: [\n        {style: {flex: 1}},\n        {style: {flex: 1, minWidth: 200}},\n        {style: {flex: 1}}\n      ]},\n      {width: 300, height: 200, top: 0, left: 0, children: [\n        {width: 50, height: 200, top: 0, left: 0},\n        {width: 200, height: 200, top: 0, left: 50},\n        {width: 50, height: 200, top: 0, left: 250}\n      ]}\n    );\n  });\n\n  it('should override flex direction size with min bounds in rtl', function() {\n    testLayout(\n      {style: {width: 300, height: 200, direction: 'rtl', flexDirection: 'row'}, children: [\n        {style: {flex: 1}},\n        {style: {flex: 1, minWidth: 200}},\n        {style: {flex: 1}}\n      ]},\n      {width: 300, height: 200, top: 0, left: 0, children: [\n        {width: 50, height: 200, top: 0, left: 250},\n        {width: 200, height: 200, top: 0, left: 50},\n        {width: 50, height: 200, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should not override flex direction size within bounds', function() {\n    testLayout(\n      {style: {width: 300, height: 200, flexDirection: 'row'}, children: [\n        {style: {flex: 1}},\n        {style: {flex: 1, minWidth: 90, maxWidth: 110}},\n        {style: {flex: 1}}\n      ]},\n      {width: 300, height: 200, top: 0, left: 0, children: [\n        {width: 100, height: 200, top: 0, left: 0},\n        {width: 100, height: 200, top: 0, left: 100},\n        {width: 100, height: 200, top: 0, left: 200}\n      ]}\n    );\n  });\n\n  it('should not override flex direction size within bounds in rtl', function() {\n    testLayout(\n      {style: {width: 300, height: 200, direction: 'rtl', flexDirection: 'row'}, children: [\n        {style: {flex: 1}},\n        {style: {flex: 1, minWidth: 90, maxWidth: 110}},\n        {style: {flex: 1}}\n      ]},\n      {width: 300, height: 200, top: 0, left: 0, children: [\n        {width: 100, height: 200, top: 0, left: 200},\n        {width: 100, height: 200, top: 0, left: 100},\n        {width: 100, height: 200, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should override flex direction size with max bounds', function() {\n    testLayout(\n      {style: {width: 300, height: 200, flexDirection: 'row'}, children: [\n        {style: {flex: 1}},\n        {style: {flex: 1, maxWidth: 60}},\n        {style: {flex: 1}}\n      ]},\n      {width: 300, height: 200, top: 0, left: 0, children: [\n        {width: 120, height: 200, top: 0, left: 0},\n        {width: 60, height: 200, top: 0, left: 120},\n        {width: 120, height: 200, top: 0, left: 180}\n      ]}\n    );\n  });\n\n  it('should override flex direction size with max bounds in rtl', function() {\n    testLayout(\n      {style: {width: 300, height: 200, direction: 'rtl', flexDirection: 'row'}, children: [\n        {style: {flex: 1}},\n        {style: {flex: 1, maxWidth: 60}},\n        {style: {flex: 1}}\n      ]},\n      {width: 300, height: 200, top: 0, left: 0, children: [\n        {width: 120, height: 200, top: 0, left: 180},\n        {width: 60, height: 200, top: 0, left: 120},\n        {width: 120, height: 200, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should ignore flex size if fully max bound', function() {\n    testLayout(\n      {style: {width: 300, height: 200, flexDirection: 'row'}, children: [\n        {style: {flex: 1, maxWidth: 60}},\n        {style: {flex: 1, maxWidth: 60}},\n        {style: {flex: 1, maxWidth: 60}}\n      ]},\n      {width: 300, height: 200, top: 0, left: 0, children: [\n        {width: 60, height: 200, top: 0, left: 0},\n        {width: 60, height: 200, top: 0, left: 60},\n        {width: 60, height: 200, top: 0, left: 120}\n      ]}\n    );\n  });\n\n  it('should ignore flex size if fully max bound in rtl', function() {\n    testLayout(\n      {style: {width: 300, height: 200, direction: 'rtl', flexDirection: 'row'}, children: [\n        {style: {flex: 1, maxWidth: 60}},\n        {style: {flex: 1, maxWidth: 60}},\n        {style: {flex: 1, maxWidth: 60}}\n      ]},\n      {width: 300, height: 200, top: 0, left: 0, children: [\n        {width: 60, height: 200, top: 0, left: 240},\n        {width: 60, height: 200, top: 0, left: 180},\n        {width: 60, height: 200, top: 0, left: 120}\n      ]}\n    );\n  });\n\n  it('should ignore flex size if fully min bound', function() {\n    testLayout(\n      {style: {width: 300, height: 200, flexDirection: 'row'}, children: [\n        {style: {flex: 1, minWidth: 120}},\n        {style: {flex: 1, minWidth: 120}},\n        {style: {flex: 1, minWidth: 120}}\n      ]},\n      {width: 300, height: 200, top: 0, left: 0, children: [\n        {width: 120, height: 200, top: 0, left: 0},\n        {width: 120, height: 200, top: 0, left: 120},\n        {width: 120, height: 200, top: 0, left: 240}\n      ]}\n    );\n  });\n\n  it('should ignore flex size if fully min bound in rtl', function() {\n    testLayout(\n      {style: {width: 300, height: 200, direction: 'rtl', flexDirection: 'row'}, children: [\n        {style: {flex: 1, minWidth: 120}},\n        {style: {flex: 1, minWidth: 120}},\n        {style: {flex: 1, minWidth: 120}}\n      ]},\n      {width: 300, height: 200, top: 0, left: 0, children: [\n        {width: 120, height: 200, top: 0, left: 180},\n        {width: 120, height: 200, top: 0, left: 60},\n        {width: 120, height: 200, top: 0, left: -60}\n      ]}\n    );\n  });\n\n  it('should pre-fill child size within bounds', function() {\n    testLayout(\n      {style: {width: 300, height: 200}, children: [\n        {style: {flex: 1, minWidth: 290, maxWidth: 310}}\n      ]},\n      {width: 300, height: 200, top: 0, left: 0, children: [\n        {width: 300, height: 200, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should pre-fill child size within max bound', function() {\n    testLayout(\n      {style: {width: 300, height: 200}, children: [\n        {style: {flex: 1, maxWidth: 290}}\n      ]},\n      {width: 300, height: 200, top: 0, left: 0, children: [\n        {width: 290, height: 200, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should pre-fill child size within min bounds', function() {\n    testLayout(\n      {style: {width: 300, height: 200}, children: [\n        {style: {flex: 1, minWidth: 310}}\n      ]},\n      {width: 300, height: 200, top: 0, left: 0, children: [\n        {width: 310, height: 200, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should set parents size based on bounded children', function() {\n    testLayout(\n      {style: {minWidth: 100, maxWidth: 300, minHeight: 500, maxHeight: 700}, children: [\n        {style: {width: 200, height: 300}},\n        {style: {width: 200, height: 300}}\n      ]},\n      {width: 200, height: 600, top: 0, left: 0, children: [\n        {width: 200, height: 300, top: 0, left: 0},\n        {width: 200, height: 300, top: 300, left: 0}\n      ]}\n    );\n  });\n\n  it('should set parents size based on max bounded children', function() {\n    testLayout(\n      {style: {maxWidth: 100, maxHeight: 500}, children: [\n        {style: {width: 200, height: 300}},\n        {style: {width: 200, height: 300}}\n      ]},\n      {width: 100, height: 500, top: 0, left: 0, children: [\n        {width: 200, height: 300, top: 0, left: 0},\n        {width: 200, height: 300, top: 300, left: 0}\n      ]}\n    );\n  });\n\n  it('should set parents size based on min bounded children', function() {\n    testLayout(\n      {style: {minWidth: 300, minHeight: 700}, children: [\n        {style: {width: 200, height: 300}},\n        {style: {width: 200, height: 300}}\n      ]},\n      {width: 300, height: 700, top: 0, left: 0, children: [\n        {width: 200, height: 300, top: 0, left: 0},\n        {width: 200, height: 300, top: 300, left: 0}\n      ]}\n    );\n  });\n\n  it('should keep stretched size within bounds', function() {\n    testLayout(\n      {style: {width: 1000, alignItems: 'stretch'}, children: [\n        {style: {height: 100, minHeight: 90, maxHeight: 110, minWidth: 900, maxWidth: 1100}}\n      ]},\n      {width: 1000, height: 100, top: 0, left: 0, children: [\n        {width: 1000, height: 100, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should keep stretched size within max bounds', function() {\n    testLayout(\n      {style: {width: 1000, alignItems: 'stretch'}, children: [\n        {style: {height: 100, maxHeight: 90, maxWidth: 900}}\n      ]},\n      {width: 1000, height: 90, top: 0, left: 0, children: [\n        {width: 900, height: 90, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should keep stretched size within min bounds', function() {\n    testLayout(\n      {style: {width: 1000, alignItems: 'stretch'}, children: [\n        {style: {height: 100, minHeight: 110, minWidth: 1100}}\n      ]},\n      {width: 1000, height: 110, top: 0, left: 0, children: [\n        {width: 1100, height: 110, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should keep cross axis size within min bounds', function() {\n    testLayout(\n      {style: {width: 1000, flexDirection: 'row'}, children: [\n        {style: {height: 100, minHeight: 110, minWidth: 100}}\n      ]},\n      {width: 1000, height: 110, top: 0, left: 0, children: [\n        {width: 100, height: 110, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  it('should keep cross axis size within min bounds in rtl', function() {\n    testLayout(\n      {style: {width: 1000, direction: 'rtl', flexDirection: 'row'}, children: [\n        {style: {height: 100, minHeight: 110, minWidth: 100}}\n      ]},\n      {width: 1000, height: 110, top: 0, left: 0, children: [\n        {width: 100, height: 110, top: 0, left: 900}\n      ]}\n    );\n  });\n\n  it('should layout node with position absolute, top and left and max bounds', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000}, children: [\n        {style: {position: 'absolute', top: 100, left: 100, bottom: 100, right: 100, maxWidth: 500, maxHeight: 600}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 500, height: 600, top: 100, left: 100}\n      ]}\n    );\n  });\n\n  it('should layout node with position absolute, top and left and min bounds', function() {\n    testLayout(\n      {style: {width: 1000, height: 1000}, children: [\n        {style: {position: 'absolute', top: 100, left: 100, bottom: 100, right: 100, minWidth: 900, minHeight: 1000}}\n      ]},\n      {width: 1000, height: 1000, top: 0, left: 0, children: [\n        {width: 900, height: 1000, top: 100, left: 100}\n      ]}\n    );\n  });\n\n  xit('should layout minHeight with a flex child', function() {\n    testLayout(\n      {style: {minHeight: 800}, children: [\n        {style: {flex: 1}}\n      ]},\n      {width: 0, height: 800, top: 0, left: 0, children: [\n        {width: 0, height: 800, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  xit('should layout node with a nested sibling child with width', function() {\n    testLayout(\n      {style: {}, children: [\n        {style: {width: 5}},\n        {style: {}, children: [\n          {style: {}}\n        ]}\n      ]},\n      {width: 5, height: 0, top: 0, left: 0, children: [\n        {width: 5, height: 0, top: 0, left: 0},\n        {width: 5, height: 0, top: 0, left: 0, children: [\n          {width: 5, height: 0, top: 0, left: 0}\n        ]}\n      ]}\n    );\n  });\n\n  it('should layout absolutely positioned node with absolutely positioned padded parent', function() {\n    testLayout(\n      {style: {width: 400, height: 400}, children: [\n        {style: {position: 'absolute', top: 100, left: 100, right: 100, bottom: 100, padding: 10}, children: [\n          {style: {position: 'absolute', top: 10, left: 10, right: 10, bottom: 10}}\n        ]}\n      ]},\n      {width: 400, height: 400, top: 0, left: 0, children: [\n        {width: 200, height: 200, top: 100, left: 100, children: [\n          {width: 180, height: 180, top: 10, left: 10}\n        ]}\n      ]}\n    );\n  });\n\n  it('should layout absolutely positioned node with absolutely positioned padded and bordered parent', function() {\n    testLayout(\n      {style: {width: 400, height: 400}, children: [\n        {style: {position: 'absolute', top: 100, left: 100, right: 100, bottom: 100, padding: 10, borderWidth: 1}, children: [\n          {style: {position: 'absolute', top: 10, left: 10, right: 10, bottom: 10}}\n        ]}\n      ]},\n      {width: 400, height: 400, top: 0, left: 0, children: [\n        {width: 200, height: 200, top: 100, left: 100, children: [\n          {width: 178, height: 178, top: 11, left: 11}\n        ]}\n      ]}\n    );\n  });\n\n  it('should layout absolutely positioned node with padded flex 1 parent', function() {\n    testLayout(\n      {style: {width: 400, height: 400}, children: [\n        {style: {flex: 1, padding: 10}, children: [\n          {style: {position: 'absolute', top: 10, left: 10, right: 10, bottom: 10}}\n        ]}\n      ]},\n      {width: 400, height: 400, top: 0, left: 0, children: [\n        {width: 400, height: 400, top: 0, left: 0, children: [\n          {width: 380, height: 380, top: 10, left: 10}\n        ]}\n      ]}\n    );\n  });\n\n  it('should layout nested nodes with mixed directions', function() {\n    testLayout(\n      {style: {width: 200, height: 200, direction: 'rtl'}, children: [\n        {style: {flexDirection: 'row'}, children: [\n          {style: {width: 50, height: 50}},\n          {style: {width: 50, height: 50}}\n        ]},\n        {style: {direction: 'ltr', flexDirection: 'row'}, children: [\n          {style: {width: 50, height: 50}},\n          {style: {width: 50, height: 50}}\n        ]}\n      ]},\n      {width: 200, height: 200, top: 0, left: 0, children: [\n        {width: 200, height: 50, top: 0, left: 0, children: [\n          {width: 50, height: 50, top: 0, left: 150},\n          {width: 50, height: 50, top: 0, left: 100}\n        ]},\n        {width: 200, height: 50, top: 50, left: 0, children: [\n          {width: 50, height: 50, top: 0, left: 0},\n          {width: 50, height: 50, top: 0, left: 50}\n        ]}\n      ]}\n    );\n  });\n\n  it('should correctly space wrapped nodes', function() {\n    testLayout(\n      {style: {width: 320, height: 200, flexDirection: 'row', justifyContent: 'space-between', flexWrap: 'wrap'}, children: [\n        {style: {width: 100, height: 100}},\n        {style: {width: 100, height: 100}},\n        {style: {width: 100, height: 100}},\n        {style: {width: 100, height: 100}},\n        {style: {width: 100, height: 100}},\n        {style: {width: 100, height: 100}}\n      ]},\n      {width: 320, height: 200, top: 0, left: 0, children: [\n        {width: 100, height: 100, top: 0, left: 0},\n        {width: 100, height: 100, top: 0, left: 110},\n        {width: 100, height: 100, top: 0, left: 220},\n        {width: 100, height: 100, top: 100, left: 0},\n        {width: 100, height: 100, top: 100, left: 110},\n        {width: 100, height: 100, top: 100, left: 220}\n      ]}\n    );\n  });\n\n\n  it('should give start/end padding precedence over left/right padding', function() {\n    testLayout(\n      {style: {width: 200, paddingLeft: 5, paddingStart: 15, paddingRight: 5, paddingEnd: 15}, children: [\n        {style: {height: 50}}\n      ]},\n      {width: 200, height: 50, top: 0, left: 0, children: [\n        {width: 170, height: 50, top: 0, left: 15}\n      ]}\n    );\n  });\n\n  it('should give start/end margin precedence over left/right margin', function() {\n    testLayout(\n      {style: {width: 200}, children: [\n        {style: {height: 50, marginLeft: 5, marginStart: 15, marginRight: 5, marginEnd: 15}}\n      ]},\n      {width: 200, height: 50, top: 0, left: 0, children: [\n        {width: 170, height: 50, top: 0, left: 15}\n      ]}\n    );\n  });\n\n  it('should give start/end border precedence over left/right border', function() {\n    testLayout(\n      {style: {width: 200, borderLeftWidth: 5, borderStartWidth: 15, borderRightWidth: 5, borderEndWidth: 15}, children: [\n        {style: {height: 50}}\n      ]},\n      {width: 200, height: 50, top: 0, left: 0, children: [\n        {width: 170, height: 50, top: 0, left: 15}\n      ]}\n    );\n  });\n\n  it('should layout node with correct start/end padding', function() {\n    testLayout(\n      {style: {width: 200, paddingStart: 15, paddingEnd: 5}, children: [\n        {style: {height: 50}}\n      ]},\n      {width: 200, height: 50, top: 0, left: 0, children: [\n        {width: 180, height: 50, top: 0, left: 15}\n      ]}\n    );\n  });\n\n  it('should layout node with correct start/end padding in rtl', function() {\n    testLayout(\n      {style: {width: 200, direction: 'rtl', paddingStart: 15, paddingEnd: 5}, children: [\n        {style: {height: 50}}\n      ]},\n      {width: 200, height: 50, top: 0, left: 0, children: [\n        {width: 180, height: 50, top: 0, left: 5}\n      ]}\n    );\n  });\n\n  it('should layout node with correct start/end margin', function() {\n    testLayout(\n      {style: {width: 200}, children: [\n        {style: {height: 50, marginStart: 15, marginEnd: 5}}\n      ]},\n      {width: 200, height: 50, top: 0, left: 0, children: [\n        {width: 180, height: 50, top: 0, left: 15}\n      ]}\n    );\n  });\n\n  it('should layout node with correct start/end margin in rtl', function() {\n    testLayout(\n      {style: {width: 200}, children: [\n        {style: {height: 50, direction: 'rtl', marginStart: 15, marginEnd: 5}}\n      ]},\n      {width: 200, height: 50, top: 0, left: 0, children: [\n        {width: 180, height: 50, top: 0, left: 5}\n      ]}\n    );\n  });\n\n  it('should layout node with correct start/end border', function() {\n    testLayout(\n      {style: {width: 200, borderStartWidth: 15, borderEndWidth: 5}, children: [\n        {style: {height: 50}}\n      ]},\n      {width: 200, height: 50, top: 0, left: 0, children: [\n        {width: 180, height: 50, top: 0, left: 15}\n      ]}\n    );\n  });\n\n  it('should layout node with correct start/end border in rtl', function() {\n    testLayout(\n      {style: {width: 200, direction: 'rtl', borderStartWidth: 15, borderEndWidth: 5}, children: [\n        {style: {height: 50}}\n      ]},\n      {width: 200, height: 50, top: 0, left: 0, children: [\n        {width: 180, height: 50, top: 0, left: 5}\n      ]}\n    );\n  });\n\n  it('should layout node with a 0 width', function() {\n    testLayout(\n      {style: {width: 200}, children: [\n        {style: {width: 0}}\n      ]},\n      {width: 200, height: 0, top: 0, left: 0, children: [\n        {width: 0, height: 0, top: 0, left: 0}\n      ]}\n    );\n  });\n\n  xit('should stretch a nested child', function() {\n    testLayout(\n      {children: [\n        {children: [{}]},\n        {style: {width: 40}}\n      ]},\n      {width: 40, height: 0, top: 0, left: 0, children: [\n        {width: 40, height: 0, top: 0, left: 0, children: [\n          {width: 40, height: 0, top: 0, left: 0}\n        ]},\n        {width: 40, height: 0, top: 0, left: 0}\n      ]}\n    );\n  });\n});\n\ndescribe('Layout alignContent', function() {\n\n  it('should layout with alignContent: stretch, and alignItems: flex-start', function() {\n    testLayout(\n      {style: {width: 300, height: 380, flexDirection: 'row', flexWrap: 'wrap', alignContent: 'stretch', alignItems: 'flex-start'},\n       children: [\n         /* 0 */ {style: {width: 50, height: 50, margin: 10}},\n         /* 1 */ {style: {width: 50, height: 50, margin: 10}},\n         /* 2 */ {style: {width: 50, height: 50, margin: 10}},\n         /* 3 */ {style: {width: 50, height: 50, margin: 10}},\n         /* 4 */ {style: {width: 50, height: 100, margin: 10}},\n         /* 5 */ {style: {width: 50, height: 50, margin: 10, alignSelf: 'flex-start'}},\n         /* 6 */ {style: {width: 50, height: 50, margin: 10}},\n         /* 7 */ {style: {width: 50, height: 100, margin: 10}},\n         /* 8 */ {style: {width: 50, height: 50, margin: 10}},\n         /* 9 */ {style: {width: 50, height: 50, margin: 10}},\n         /* 10 */ {style: {width: 50, height: 50, margin: 10, alignSelf: 'flex-start' }},\n         /* 11 */ {style: {width: 50, height: 50, margin: 10}},\n         /* 12 */ {style: {width: 50, height: 50, margin: 10}},\n         /* 13 */ {style: {width: 50, height: 50, margin: 10, alignSelf: 'flex-start'}},\n         /* 14 */ {style: {width: 50, height: 50, margin: 10}}\n       ]\n      },\n      {width: 300, height: 380, top: 0, left: 0, children: [\n        {width: 50, height: 50, top: 10, left: 10},\n        {width: 50, height: 50, top: 10, left: 80},\n        {width: 50, height: 50, top: 10, left: 150},\n        {width: 50, height: 50, top: 10, left: 220},\n        {width: 50, height: 100, top: 92.5, left: 10},\n        {width: 50, height: 50, top: 92.5, left: 80},\n        {width: 50, height: 50, top: 92.5, left: 150},\n        {width: 50, height: 100, top: 92.5, left: 220},\n        {width: 50, height: 50, top: 225, left: 10},\n        {width: 50, height: 50, top: 225, left: 80},\n        {width: 50, height: 50, top: 225, left: 150},\n        {width: 50, height: 50, top: 225, left: 220},\n        {width: 50, height: 50, top: 307.5, left: 10},\n        {width: 50, height: 50, top: 307.5, left: 80},\n        {width: 50, height: 50, top: 307.5, left: 150}\n      ]}\n    );\n  });\n\n\n  function testAlignContent(alignContent, alignItems) {\n    it('should layout with alignContent: ' + alignContent + ', and alignItems: ' + alignItems, function() {\n      testLayoutAgainstDomOnly(\n        {style: {width: 300, height: 380, flexDirection: 'row', flexWrap: 'wrap', alignContent: alignContent, alignItems: alignItems},\n         children: [\n           /* 0 */ {style: {width: 50, height: 50, margin: 10}},\n           /* 1 */ {style: {width: 50, height: 50, margin: 10}},\n           /* 2 */ {style: {width: 50, height: 50, margin: 10}},\n           /* 3 */ {style: {width: 50, height: 50, margin: 10}},\n           /* 4 */ {style: {width: 50, height: 100, margin: 10}},\n           /* 5 */ {style: {width: 50, height: 50, margin: 10, alignSelf: 'flex-start'}},\n           /* 6 */ {style: {width: 50, height: 50, margin: 10}},\n           /* 7 */ {style: {width: 50, height: 100, margin: 10}},\n           /* 8 */ {style: {width: 50, height: 50, margin: 10}},\n           /* 9 */ {style: {width: 50, height: 50, margin: 10}},\n           /* 10 */ {style: {width: 50, height: 50, margin: 10, alignSelf: 'flex-start' }},\n           /* 11 */ {style: {width: 50, height: 50, margin: 10}},\n           /* 12 */ {style: {width: 50, height: 50, margin: 10}},\n           /* 13 */ {style: {width: 50, height: 50, margin: 10, alignSelf: 'flex-start'}},\n           /* 14 */ {style: {width: 50, height: 50, margin: 10}}\n         ]\n        }\n      );\n    });\n  }\n  testAlignContent('stretch', 'center');\n  testAlignContent('stretch', 'flex-end');\n  testAlignContent('stretch', 'stretch');\n\n  testAlignContent('flex-start', 'flex-start');\n  testAlignContent('flex-start', 'center');\n  testAlignContent('flex-start', 'flex-end');\n  testAlignContent('flex-start', 'stretch');\n\n  testAlignContent('center', 'flex-start');\n  testAlignContent('center', 'center');\n  testAlignContent('center', 'flex-end');\n  testAlignContent('center', 'stretch');\n\n  testAlignContent('flex-end', 'flex-start');\n  testAlignContent('flex-end', 'center');\n  testAlignContent('flex-end', 'flex-end');\n  testAlignContent('flex-end', 'stretch');\n});\n"}